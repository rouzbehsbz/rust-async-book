<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js rust">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>برنامه نویسی Async در زبان Rust</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/custom.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "rust";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="00_introduction/01_introduction.html"><strong aria-hidden="true">1.</strong> چند تا نکته</a></li><li class="chapter-item expanded "><a href="01_getting_started/01_chapter.html"><strong aria-hidden="true">2.</strong> مقدمه و شروع کار</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="01_getting_started/02_why_async.html"><strong aria-hidden="true">2.1.</strong> چرا Async ؟</a></li><li class="chapter-item expanded "><a href="01_getting_started/03_state_of_async_rust.html"><strong aria-hidden="true">2.2.</strong> وضعیت کنونی Rust در حالت Async</a></li><li class="chapter-item expanded "><a href="01_getting_started/04_async_await_primer.html"><strong aria-hidden="true">2.3.</strong> کلیدواژه های async/await</a></li></ol></li><li class="chapter-item expanded "><a href="02_execution/01_chapter.html"><strong aria-hidden="true">3.</strong> زیر و بم اجرای کد های Async با Future</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="02_execution/02_future.html"><strong aria-hidden="true">3.1.</strong> نگاه دقیق به Future Trait</a></li><li class="chapter-item expanded "><a href="02_execution/03_wakeups.html"><strong aria-hidden="true">3.2.</strong> بیدار کردن یک عملیات Async با Waker</a></li><li class="chapter-item expanded "><a href="02_execution/04_executor.html"><strong aria-hidden="true">3.3.</strong> پیاده سازی یک اجراکننده برای عملیات Async</a></li><li class="chapter-item expanded "><a href="02_execution/05_io.html"><strong aria-hidden="true">3.4.</strong> اجراکننده ها و IO سیستم</a></li></ol></li><li class="chapter-item expanded "><a href="03_async_await/01_chapter.html"><strong aria-hidden="true">4.</strong> async/await</a></li><li class="chapter-item expanded "><a href="04_pinning/01_chapter.html"><strong aria-hidden="true">5.</strong> Pin کردن</a></li><li class="chapter-item expanded "><a href="05_streams/01_chapter.html"><strong aria-hidden="true">6.</strong> Stream ها</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="05_streams/02_iteration_and_concurrency.html"><strong aria-hidden="true">6.1.</strong> پیمایش و همزمانی ها در کد</a></li></ol></li><li class="chapter-item expanded "><a href="06_multiple_futures/01_chapter.html"><strong aria-hidden="true">7.</strong> اجرا کردن چندین Future به طور همزمان</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="06_multiple_futures/02_join.html"><strong aria-hidden="true">7.1.</strong> ماکرو !join</a></li><li class="chapter-item expanded "><a href="06_multiple_futures/03_select.html"><strong aria-hidden="true">7.2.</strong> ماکرو !select</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.3.</strong> تکمیل نشده: Spawn کردن</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.4.</strong> تکمیل نشده: متوقف کردن و Timeout ها</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.5.</strong> تکمیل نشده: Future های بدون ترتیب</div></li></ol></li><li class="chapter-item expanded "><a href="07_workarounds/01_chapter.html"><strong aria-hidden="true">8.</strong> راه حل هایی که باید بدونیم و دوستشون داشته باشیم</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="07_workarounds/02_err_in_async_blocks.html"><strong aria-hidden="true">8.1.</strong> علامت ؟ در بلوک های کد Async</a></li><li class="chapter-item expanded "><a href="07_workarounds/03_send_approximation.html"><strong aria-hidden="true">8.2.</strong> Send و همزمانی ترد ها</a></li><li class="chapter-item expanded "><a href="07_workarounds/04_recursion.html"><strong aria-hidden="true">8.3.</strong> بازگشتی ها</a></li><li class="chapter-item expanded "><a href="07_workarounds/05_async_in_traits.html"><strong aria-hidden="true">8.4.</strong> Async در Trait ها</a></li></ol></li><li class="chapter-item expanded "><a href="08_ecosystem/00_chapter.html"><strong aria-hidden="true">9.</strong> اکوسیستم کد Async</a></li><li class="chapter-item expanded "><a href="09_example/00_intro.html"><strong aria-hidden="true">10.</strong> پروژه نهایی: سرور HTTP</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="09_example/01_running_async_code.html"><strong aria-hidden="true">10.1.</strong> اجرا کردن کد Async</a></li><li class="chapter-item expanded "><a href="09_example/02_handling_connections_concurrently.html"><strong aria-hidden="true">10.2.</strong> پردازش کانکشن ها به صورت همزمان</a></li><li class="chapter-item expanded "><a href="09_example/03_tests.html"><strong aria-hidden="true">10.3.</strong> تست کردن سرور</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.</strong> تکمیل نشده: I/O</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">11.1.</strong> تکمیل نشده: AsyncRead و AsyncWrite</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.</strong> تکمیل نشده: الگو های طراحی در برنامه نویسی Async: راه حل ها و پیشنهاد ها</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">12.1.</strong> تکمیل نشده: مدل سازی سرور ها و الگوی طراحی سیستم های Request/Response</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.2.</strong> تکمیل نشده: مدیریت State های اشتراکی و Share شده</div></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">برنامه نویسی Async در زبان Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rouzbehsbz/rust-async-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="چند-تا-نکته"><a class="header" href="#چند-تا-نکته">چند تا نکته</a></h1>
<p>این کتاب ترجمه کتاب اصلی به همین عنوان هست و سعی شده به صورت فارسی روان ترجمه بشه.
برای اینکه حس کردم شاید کسی که میخونه با زبان عامیانه بیشتر ارتباط برقرار کنه تا خیلی رسمی، متن کتاب هم به صورت فارسی عامیانه ترجمه شده
و شاید خیلی از کلمات و لغات از نظر نگارشی اشتباه باشن. بعضی جاهای کتاب شاید ترجمش
خیلی خوب از آب در نیومده، اگه دوست داشتید و ترجمه بهتری برای قسمت های مختلف داشتید حتما contribute .کنید
تا این لحظه که من این مقدمه رو مینوسیم خیلی منابع درست حسابی برنامه نویسی Async داخل Rust وجود نداره، این کتاب هم
یکم مطالب و متد هاش شاید قدیمی شده باشه و اینجوری که توی repository اصلیش صحبت میکنن قصد آپدیت کردنشم ندارن دیگه متاسفانه.
ولی خب همینم توی comminuty فارسی جاش خالیه و خوندنش برای آشنا شدن با مفاهیم زیرساختی و پایه ای Async خیلی خوبه.
حتما سراغ crate های مدرن و پیشرفته تر دیگه مثل tokio هم برید و سعی کنید با اونا کار کنید.
در نهایت خیلی خوشحال میشم اگه تو بهتر کردن این کتاب کمک کنید :) البته خیلی درست نیست متن اصلیو عوض کنیم ولی میشه قطعا ترجمشو بهتر کرد.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="مقدمه-و-شروع-کار"><a class="header" href="#مقدمه-و-شروع-کار">مقدمه و شروع کار</a></h1>
<p>به برنامه نویسی Async در Rust خوش اومدی! اگه دنبال این هستی که شروع کنی به نوشتن کد های Async در Rust جای درست و خوبی اومدی. فرقی نمیکنه در حال نوشتن یک وب سرور، دیتابیس یا حتی یه سیستم عامل هستی، این کتاب بهت نشون میده چجوری با ابزار های Async در Rust بهترین بازده رو از سخت افزارت بگیری.</p>
<h2 id="این-کتاب-چه-چیزهایی-رو-پوشش-میده"><a class="header" href="#این-کتاب-چه-چیزهایی-رو-پوشش-میده">این کتاب چه چیزهایی رو پوشش میده؟</a></h2>
<p>هدف این کتاب اینه که یک منبع جامع و بروز از راهنمای استفاده از ویژگی های Async زبان Rust و کتابخانه هاش، چه برای مبتدی ها و چه برای خفن ها و قدیمیای Rust باشه.</p>
<ul>
<li>
<p>فصل های اول کتاب مقدمه های کلی برای ورود به برنامه نویسی Async، به همراه دیدگاه Rust نسبت به برنامه Async رو توضیح میده.</p>
</li>
<li>
<p>فصل های میانی در مورد ابزار های کلیدی، مفید و کنترلی در زمان نوشتن کد Async بحث میکنه، و توضیح میده چجوری کتابخانه ها و برنامه هایی با سرعت و امکان استفاده طولانی مدت با استفاده از بهترین الگوهایی که قبلا تست شده بسازیم.</p>
</li>
<li>
<p>قسمت آخر کتاب اکوسیستم های بزرگتر Async به همراه چند مثال در مورد نحوه نوشتن یک سری کد های رایج Async رو پوشش میده.</p>
</li>
</ul>
<p>بعد از یه مقدمه نه چندان طولانی، بهتره سراغ دنیای جذاب برنامه نویسی Async در Rust بریم!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="چرا-async-"><a class="header" href="#چرا-async-">چرا Async ؟</a></h1>
<p>ما همه عاشق قدرتی هستیم که Rust در نوشتن نرم افزار های سریع و امن میده، اما برنامه نویسی Async چجوری میتونه تو این دیدگاه جا داشته باشه ؟</p>
<p>برنامه نویسی Asynchronous یا Async، یک <em>مدل برنامه نویسی همزمان</em> هست که توسط تعداد زیادی از زبان های برنامه نویسی پشتیبانی میشه، که این امکان رو به شما میده که تعداد زیادی عملیات رو روی تعداد کمی thread سیستم عاملی انجام بدید. این در حالیه که کدی که مینویسید به خاطر کلید واژه های <code>async/await</code> از نظر ظاهری و حسی خیلی شبیه برنامه های عادی sync هست.</p>
<h2 id="مقایسه-async-و-دیگر-مدل-های-همزمانی"><a class="header" href="#مقایسه-async-و-دیگر-مدل-های-همزمانی">مقایسه Async و دیگر مدل های همزمانی</a></h2>
<p>برنامه نویسی همزمان نسبت به برنامه نویسی معمولی و متوالی هنوز پخته نشده و استاندارد هاش کمتره، در نتیجه بسته به اینکه اون زبان برنامه نویسی از کدوم مدل همزمانی پشتیبانی میکنه، همزمانی رو به صورت های مختلفی میشه بیان کرد. یه مرور سریع روی محبوب ترین مدل های برنامه نویسی همزمان میتونه بهتون در فهمیدن اینکه برنامه نویسی Async چه جایگاهی در این حوزه وسیع داره کمک کنه:</p>
<ul>
<li>
<p><strong>Thread های سیستم عاملی:</strong> تو این روش نیازی به تغییر تو مدل برنامه نویسی وجود نداره، که همین موضوع رسیدن به مدل همزمانی رو خیلی آسون تر میکنه. البته sync کردن و همزمان کردن thread ها خودش میتونه در مواقعی خیلی سخت باشه، و در ضمن تو این روش سربار و افت سرعت قابل توجه هست. روش هایی مثل Thread Pool میتونه یکم تو کم کردن این سربار ها و افزایش سرعت کارساز باشه، ولی در نهایت برای حجم زیاد عملیات هایی که محدود به I/O هستند کافی نیست.</p>
</li>
<li>
<p><strong>برنامه نویسی Event محور:</strong> این روش با استفاده از <em>callback</em> ها میتونه سرعت رو افزایش بده، ولی منجر به ایجاد یه جریان غیر خطی توی برنامه میشه که پیگیری و عیب یابی از این نوع برنامه رو سخت میکنه.</p>
</li>
<li>
<p><strong>روش Coroutine:</strong> مثل thread ها تغیری توی مدل برنامه نویسی نیاز ندارن، که استفاده ازشون رو راحت تر میکنه. مثل Async میتونن تعداد زیادی عملیات رو به طور همزمان پوشش بدن. با این وجود یه سری جزئیات سطح پایین که برای برنامه نویسی سیستم و runtime های خاص مهم هستند رو در نظر نمیگیره.</p>
</li>
<li>
<p><strong>مدل بازیگر (Actor):</strong> در این روش تمام محاسبات همزمان به صورت واحد هایی به اسم بازیگر تقسیم میشن، که با هم در ارتباط هستن، دقیقا شبیه سیستم های توزیع شده. این روش میتونه خیلی بهینه پیاده سازی بشه اما بسیاری از مسائل کاربردی مثل کنترل جریان و منطق مجدد (مثلا بعد از یک خطا) رو بی پاسخ میزاره.</p>
</li>
</ul>
<p>به طور خلاصه، برنامه نویسی Async این اجازه رو به شما میده که برنامه های فوق العاده بهینه و با سرعت بالا برای زبان های سطح پایینی مثل Rust پیاده سازی کنید، در حالی که بسیاری از مزایای thread ها و دیگر روش ها رو هم پوشش میدن.</p>
<h2 id="async-در-rust-در-مقایسه-با-بقیه-زبان-ها"><a class="header" href="#async-در-rust-در-مقایسه-با-بقیه-زبان-ها">Async در Rust در مقایسه با بقیه زبان ها</a></h2>
<p>اگرچه برنامه نویسی Async توسط خیلی از زبان ها پشتیبانی میشه، ولی تو بعضی از جزئیات وقتی به قسمت پیاده سازی میرسیم با هم دیگه فرق دارن. پیاده سازی Async ولی روشی که تو Rust ازش استفاده میشه با بیشتر زبان ها تو زمینه های زیر فرق داره:</p>
<ul>
<li>
<p><strong>Future های بی جان:</strong> Future ها توی Rust تا وقتی صداشون نزنید و چیزی که قرار بوده بهتون بدن رو ازشون نگیرید پردازشی رو جلو نمیبرن. نگه نداشتن Future ها باعث میشه عملیاتی که داشتن انجام میدادن دیگه تا آخر انجام نشه و متوقف بشه.</p>
</li>
<li>
<p><strong>Async بدون هزینه هست:</strong> توی Rust استفاده از Async هزینه ای نداره، این یعنی شما از نظر سخت افزاری فقط هزینه چیزایی که استفاده میکنید رو میدید، نکته قابل توجهش اینه که میتونید بدون گرفتن فضای heap از ram از Async استفاده کنید و به صورت پویا نتیجه عملیات Async رو انجام بدید که برای سرعت سیستم خیلی چیزه خوبیه.</p>
</li>
<li>
<p><strong>Runtime حاظر و آماده ای وجود نداره:</strong> توی Rust برای داستان Async هیچ runtime آماده ای وجود نداره. در عوض runtime ها توسط جامعه برنامه نویسان Rust نوشته شده و به صورت پکیج های قابل نصب crate موجوده.</p>
</li>
<li>
<p><strong>runtime های single-thread و multi-thread موجوده:</strong> توی Rust هر دو نوع runtime های single-thread ای و multi-thread ای موجوده، که البته هر کدوم مزایا و معایب خودشونو دارن.</p>
</li>
</ul>
<h2 id="تفاوت-async-و-استفاده-از-thread-ها-در-rust"><a class="header" href="#تفاوت-async-و-استفاده-از-thread-ها-در-rust">تفاوت Async و استفاده از Thread ها در Rust</a></h2>
<p>جایگزین اصلی برای Async در Rust استفاده از thread های سیستم عاملی هست، چه به صورت مستقیم با استقاده از <a href="https://doc.rust-lang.org/std/thread/"><code>std::thread</code></a> یا به صورت غیر مستقیم با استفاده از thread pool.
مهاجرت از thread ها به Async و برعکس معمولا نیاز به بازنویسی اساسی توی کد داره، هم از نظر پیاده سازی و هم نظر ساختن یک راه ارتباطی عمومی برای قسمت های مختلف (وقتی مثلا یک کتابخانه میسازید). به همین خاطر انتخاب مدلی که دقیقا طبق نیاز های سیستم شما باشه میتونه تو زمان پیاده سازی خیلی صرفه جویی کنه.</p>
<p><strong>Thread های سیستم عاملی</strong> برای انجام task ها و عملیات مختلف تو مقیاس کم مناسب هستن، چون thread ها یه سربار اضافه تری برای CPU و حافظه (RAM) هستن. ساخت و تعویض بین thread هااز نظر سخت افزاری خیلی هزینه بره حتی thread هایی که استفاده نمیشن یا به اصطلاح idle هستن هم منابع مصرف میکنن.
استفاده از thread pool میتونه تو کم کردن این هزینه ها تاثیر داشته باشه، ولی نه تو همه چی.
اگرچه thread ها این اجازه رو به شما میدن که از همون کد عادی sync بدون تغییرات خیلی اساسی بتونید استفاده کنید و هیچ مدل برنامه نویسی نیاز نداره.
همچنین توی بعضی سیستم عامل ها میتونید اولویت اجرای thread ها رو عوض کنید، که میتونه خیلی چیزه مفیدی برای driver ها یا برنامه هایی که خیلی حساس به زمان اجرا و latency هستن باشه.</p>
<p><strong>روش Async</strong> به طور چشمگیری استفاده از CPU و حافظه رو کاهش میده، مخصوصا برای کارهایی که به طور خاص I/O زیادی دارن، مثل سرور ها یا دیتابیس ها. به همین خاطر میتونید task ها و عملیات بیشتری نسبت به thread های سیستم عاملی داشته باشید، چون یک runtime ای که به صورت async هست از تعداد thread های کمتر (که برای ما هزینه بر بودن) برای اجرای عملیات و task های بیشتر (که از نظر منابعی که استفاده میکنن کم هزینه تر هستن) استفاده میکنه.</p>
<p>یک نکته ای که آخر باید اشاره کنیم اینه که برنامه نویسی Async <em>بهتر</em> از thread ها نیست، در واقع تفاوتشونه که مهمه.
اگه به Async برای رسیدن به نتایج بهتر توی سرعت نیاز ندارید، thread ها معمولا جایگزین های راحت تری هستن.</p>
<h3 id="مثالی-از-دانلود-فایل-ها-به-صورت-همزمان"><a class="header" href="#مثالی-از-دانلود-فایل-ها-به-صورت-همزمان">مثالی از دانلود فایل ها به صورت همزمان</a></h3>
<p>تو این مثال هدف ما دانلود دو تا صفحه وب به صورت همزمانه.
توی یه برنامه معمول برای اینکار نیاز داریم که thread های جدید ایجاد کنیم تا به همزمانی برسیم:</p>
<pre><code class="language-rust ignore">fn get_two_sites() {
    // ایجاد دو تا ترد جدید که کار دانلود رو انجام بده.
    let thread_one = thread::spawn(|| download(&quot;https://www.foo.com&quot;));
    let thread_two = thread::spawn(|| download(&quot;https://www.bar.com&quot;));

    // صبر میکنیم تا هردو ترد کارشون تموم شه
    thread_one.join().expect(&quot;thread one panicked&quot;);
    thread_two.join().expect(&quot;thread two panicked&quot;);
}
</code></pre>
<p>این درحالیه که دانلود کردن یک صفحه وب یک کار خیلی کوچیکه و ایجاد thread جدید برای همچین کار کوچیکی واقعا هزینه سخت افزاری زیادی از ما میگیره. برای برنامه های بزرگتر این مسئله خیلی راحت میتونه تبدیل به یه معضل بزرگ بشه، توی برنامه نویسی Async در Rust میتونیم همین کار رو بکنیم بدون نیاز به ساختن thread های اضافی:</p>
<pre><code class="language-rust ignore">async fn get_two_sites_async() {
    // ایجاد دو تا فیوچر جدید که پس از تموم شدن کارشون
    // صفحات وب رو به صورت ناهمزمان دانلود میکنن
    let future_one = download_async(&quot;https://www.foo.com&quot;);
    let future_two = download_async(&quot;https://www.bar.com&quot;);

    // هر دو فیوچر رو اجرا میکنیم که در یک زمان کارشون تموم شه
    join!(future_one, future_two);
}
</code></pre>
<p>اینجا هیچ thread اضافه ای ساخته نشده. تمام توابعی که صداشون زدیم به صورت ثابت استفاده شدن، و هیچ استفاده ای از قسمت heap توی ram نکردیم!
اگرچه نیاز داریم که کد رو به صورت async بنویسم در وحله اول، که این کتاب دقیقا میخواد به شما تو رسیدن این هدف کمک کنه.</p>
<h2 id="مدل-های-همزمانی-شخصی-سازی-شده-در-rust"><a class="header" href="#مدل-های-همزمانی-شخصی-سازی-شده-در-rust">مدل های همزمانی شخصی سازی شده در Rust</a></h2>
<p>در آخر باید بگیم که Rust شما رو اجبار به انتخاب بین دو مدل thread و async نمیکنه.
شما میتونید از هر دو مدل توی یه برنامه استفاده کنید، که میتونه خیلی هم مفید باشه وقتی thread هایی دارید که به عملیات های async وابستگی دارن.
در حقیقت، شما میتونید حتی از مدل های همزمانی مختلف دیگه هم استفاده کنید مثل مدل Event محور یا چیزای دیگه، تا وقتی کتابخانه هایی دارید که اینا رو پیاده سازی کردن.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="وضعیت-کنونی-rust-در-حالت-async"><a class="header" href="#وضعیت-کنونی-rust-در-حالت-async">وضعیت کنونی Rust در حالت Async</a></h1>
<p>قسمت هایی از حالت Async در Rust مشابه قسمت های عادی و معمولی sync با ثبات بالا و خیلی خوبی پشتیبانی و تضمین می شود. قسمت های دیگه هنوز به ثبات کافی نرسیده اند و در حال تفییر هستند. موارد زیر رو میتونید از Rust در حالت Async انتظار داشته باشید:</p>
<ul>
<li>عملکرد فوق العاده با سرعت بالا در زمان اجرا برای task ها و عملیات مرسومی که به صورت همزمان انجام می شوند.</li>
<li>تعامل خوب با قسمت های پیشرفته زبان مثل Lifetime ها و Pin کردن.</li>
<li>وجود یک سری محدودیت های سازگاری بین کد sync و async و بین runtime های مختلف.</li>
<li>به خاطر تغییراتی که در حال حاضر روی Async داره صورت میگیره از نظر نگهداری کد باید دقت بیشتری کنید.</li>
</ul>
<p>به طور خلاصه استفاده از Async در Rust سخت تر از حالت عادی و کد sync هست ولی در عین حال بهترین سرعت رو تو مواردی که راجبش صحبت کردیم بهمون میده، البته اینم باید گفت که Async دائما در حال پیشرفته بنابراین این مسائل تو طول زمان از بین میره.</p>
<h2 id="پشتیبانی-زبان-و-کتابخانه-ها"><a class="header" href="#پشتیبانی-زبان-و-کتابخانه-ها">پشتیبانی زبان و کتابخانه ها</a></h2>
<p>در حالی که برنامه نویسی Async توسط خود Rust پشتیبانی میشه، بیشتر برنامه های Async وابسته به عملکر کتابخانه هایی هستن که جامعه برنامه نویسان Rust اونا رو نوشتن و در قالب crate ها نگهداری میکنن.
بنابراین شما باید رو ترکیبی از ویژگی های خود زبان و کتابخانه های موجود برنامه های Async تون رو جلو ببرید:</p>
<ul>
<li>بیشتر trait های پایه ای، type ها و توابع Async مثل <a href="https://doc.rust-lang.org/std/future/trait.Future.html"><code>Future</code></a> که توسط کتابخانه اصلی و استاندارد Rust فراهم شده.</li>
<li>کلیدواژه های <code>async/await</code> توسط خود کامپایلر Rust پشتیبانی میشه.</li>
<li>خیلی از type ها، ماکرو ها و توابع توسط پیکیجی به اسم <a href="https://docs.rs/futures/"><code>futures</code></a> فراهم شده. که میشه ازشون داخل هر برنامه Async که با Rust نوشته شده استفاده کرد.</li>
<li>اجرا کردن کد async، IO ها و ساخت task های جدید توسط runtime های async صورت میگیره. دو تا از این runtime ها Tokio و async-std هستن. خیلی از برنامه های Async و کتابخانه های Async داخل crate به یک runtime خاص وابستگی دارن. برای جزئیات بیشتر بخش <a href="01_getting_started/../08_ecosystem/00_chapter.html">&quot;اکوسیستم کد Async&quot;</a> رو مطالعه کنید.</li>
</ul>
<p>خیلی از ویژگی های زبان که عادت داشتید توی کد معمولی sync استفاده کنید هنوز داخل Async موجود نیستن. این نکته هم قابل ذکر هست که Rust اجازه نمیده توابعی از نوع Async داخل trait ها تعریف کنید، در عوض برای اینکه به نتیجه ای که میخواید برسید باید روش ها و الگو های کمی پیچیده تری رو طی کنید.</p>
<h2 id="کامپایل-و-خطایابی-debuging"><a class="header" href="#کامپایل-و-خطایابی-debuging">کامپایل و خطایابی (Debuging)</a></h2>
<p>برای بیشتر قسمت ها، خطاهای مربوط به کامپایلر و runtime توی کد async دقیقا مشابه حالت عادی توی Rust کار میکنه. البته یک سری نکاتی وجود داره که مطرح کردنش خالی از لطف نیست:</p>
<h3 id="خطاهای-کامپایل"><a class="header" href="#خطاهای-کامپایل">خطاهای کامپایل</a></h3>
<p>خطاهای کامپایل در حالت Async در Rust دقیقا مشابه حالت عادی و sync خیلی دقیق و طبق استاندارد های همیشگی هستن، ولی از اونجایی که حالت Async معمولا وابسته به ویژگی های پیچیده تر زبان مثل Lifetime ها و Pin کردن هست، احتمال این که از این نوع خطا ها موقع نوشتن برنامه های Async بکنید بیشتره.</p>
<h3 id="خطاهای-runtime"><a class="header" href="#خطاهای-runtime">خطاهای Runtime</a></h3>
<p>هر موقع کامپایل به یک تابع از نوع Async بر بخوره، یک state یا یه متغیر برای وضعیتش تو زیرساخت خودش براش در نظر میگیره.
اطلاعاتی که برای ردیابی یه خطا وجود داره (Stack traces) معمولا اطلاعاتی از این state ها به ما میده، همچنین توضیح میده توسط چه توابعی داخل runtime به مشکل خورده. بنابراین تفسیر این خطاها شاید کمی بیشتر از کد های معمول و sync ما رو درگیر کنه.</p>
<h3 id="حالت-های-جدید-fail-شدن-برنامه"><a class="header" href="#حالت-های-جدید-fail-شدن-برنامه">حالت های جدید Fail شدن برنامه</a></h3>
<p>چند حالت جدید برای به مشکل خوردن و fail شدن برنامه های Async وجود داره، برای مثال اگه یک تابعی که باعث block شدن منابع خاصی میشه رو به صورت Async صدا بزنید یا مفاهیم <code>Future</code> رو اشتباه پیاده سازی کنید احتمال داره برنامتون به شکل های جدیدی که قبلا نبوده fail بشه.
این خطاها و مشکلات ممکنه خیلی بی سرو صدا قوانین کامپایلر و حتی unit تست هایی که نوشتید رو رد کنه و هیچکس بهشون گیر نده. درک عمیق از مفهوم های پایه ای Async که دقیقا کاریه که این کتاب براتون انجام میده باعث میشه این مشکلات تو برنامتون به وجود نیاد.</p>
<h2 id="ملاحظاتی-که-باید-موقع-سازگاری-کد-بهش-توجه-بشه"><a class="header" href="#ملاحظاتی-که-باید-موقع-سازگاری-کد-بهش-توجه-بشه">ملاحظاتی که باید موقع سازگاری کد بهش توجه بشه</a></h2>
<p>کد Async و Sync نمیتونن همیشه خیلی آزادانه با هم ترکیب بشن.
برای مثال، شما نمیتونید یک تابع Async رو مستقیما از داخل یک تابع sync صدا بزنید.
در ضمن معمولا نوشتن کد sync و Async سبک ها و الگو های طراحی متفاوت از همی رو میطلبه، که همین مسئله میتونه اجرا کردن کد توی محیط های مختلف رو دشوار تر کنه.</p>
<p>حتی خود کد های Async هم همیشه نمیتونن آزادانه با هم ترکیب بشن.
بعضی از کتابخانه ها و پکیج های crate وابسته به یک runtime خاص هستن تا کار کنن. که البته اگه اینطوری باشه باید داخل لیست وابستگی های اون crate این مورد رو مطرح کرده باشه.</p>
<p>این مشکلات مربوط به سازگاری کد با کتابخانه ها و محیط های مختلف دست شما رو انتخاب هاتون بسته تر میکنه، پس مطمئن حتما قبلش مطمئن شوید که راجب crate ها و runtime های مختلف تحقیقاتتون رو کردید. زمانی که یه rumtime مشخص رو انتخاب کردید، نیازی نیست نگران سازگاری کدتون باشید.</p>
<h2 id="ویژگی-های-عملکردی-از-نظر-سرعت"><a class="header" href="#ویژگی-های-عملکردی-از-نظر-سرعت">ویژگی های عملکردی از نظر سرعت</a></h2>
<p>سرعت و عملکرد کد Async در Rust وابسته به runtime ای هست که ازش استفاده میکنید.
اگرچه runtime هایی که قدرت Async به Rust میدن تقریبا جدید هستن، واقعا برای اکثر مواقع و کار ها عملکرد خیلی خوبی دارن.</p>
<p>بیشتر اکوسیستم های Async شرایط <em>multi-thread</em> رو توی runtime هایشون در نظر میگیرن.
این باعث میشه لذت بردن از مزایای تئوری که در شرایط single-thread ای وجود داره سخت تر بشه.
یکی دیگه از مواردی که بهش توجهی نشده عملیات و task هایی هستن که <em>حساس به زمان</em> هستن و تاخیر اجرا توشون خیلی مهمه، که واقعا مورد مهمی برای درایور ها یا برنامه هایی که رابط گرافیکی (GUI) دارن حساب میشه. اینجور برنامه ها نیاز دارن تا runtime ها یا/و سیستم عامل قابلیت زمان بندی دقیق اجراشون رو داشته باشه. میتونید در آینده انتظار کتابخانه های بهتری برای پشتیبانی از این موارد داشته باشید.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="کلیدواژه-های-asyncawait"><a class="header" href="#کلیدواژه-های-asyncawait">کلیدواژه های async/await</a></h1>
<p><code>async</code>/<code>.await</code> ابزار های Rust برای نوشتن توابع Async هستن که باعث میشه کد خیلی شبیه به کد sync به نظر بیاد.
<code>async</code> یک بلاک کد رو تبدیل میکنه به یک وضعیت یا state machine که trait ای به اسم <code>Future</code> رو ازش استفاده و پیاده سازی کرده.
در حالی که صدا زدن یک تابع که که کل thread رو نگه میداره یا اصطلاحا بلاک میکنه، <code>Future</code> های بلاک شده کنترل thread رو بخودش برمیگردونن و باعث میشن <code>Future</code> های دیگه اجرا بشن.</p>
<p>بیاید یه پکیج crate رو به فایل <code>Cargo.toml</code> پروژمون اضافه کنیم:</p>
<pre><code class="language-toml">[dependencies]
futures = &quot;0.3&quot;
</code></pre>
<p>برای ساختن یک تابع Async، میتونید از کلیدواژه <code>async fn</code> استفاده کنید:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn do_something() { /* ... */ }
<span class="boring">}
</span></code></pre></pre>
<p>چیزی که اون تابع <code>async fn</code> برمیگردونه یک <code>Future</code> هست. برای اینکه در ادامه چیزی اتفاق بیفته، اون <code>Future</code> باید توسط یک اجرا کننده اجرا بشه.</p>
<pre><pre class="playground"><code class="language-rust edition2018">// تابع &quot;بلاک آن&quot; تردی که در آن اجرا می شود را بلاک و مسدود میکند
// و وقتی آزاد می شود که اون &quot;فیوچر&quot;ی که در حال اجرای آن است به پایان برسد
// اجرا کننده های دیگه رفتار های پیچیده تری از خودشون نشون میدن
// مثل زمان بندی برای اجرای چند فیوچر در یک ترد
use futures::executor::block_on;

async fn hello_world() {
    println!(&quot;hello, world!&quot;);
}

fn main() {
    let future = hello_world(); // اینجا هیچی پرینت نمیشه
    block_on(future); // تابع &quot;فیوچر&quot; اجرا شد و متن بالا پرینت شد
}
</code></pre></pre>
<p>داخل یک تابع <code>async fn</code>، میتونید از <code>.await</code> استفاده کنید تا برای تموم شدن اجرای یک type دیگه ای که اونم از نوع <code>Future</code> هست صبر کنید، مثلا خروجی یک تابع <code>async fn</code> دیگه. برعکس <code>block_on</code>، <code>.await</code> اون thread رو بلاک و مسدود نمیکنه، در ازاش به صورت ناهمزمان و Async برای تموم شدن یک future صبر میکنه، و این کار اجازه میده تا task ها و عملیات های دیگه اجرا بشن اگه در حال حاضر اون future قادر به ادامه پردازشش نیست.</p>
<p>برای مثال فرض کنید با سه تابع <code>async fn</code> داریم به اسم های <code>learn_song</code>، <code>sing_song</code> و <code>dance</code>:</p>
<pre><code class="language-rust ignore">async fn learn_song() -&gt; Song { /* ... */ }
async fn sing_song(song: Song) { /* ... */ }
async fn dance() { /* ... */ }
</code></pre>
<p>یه راه برای صدا زدن این سه تابع اینه که به صورت تک تک بهشون برسیم و thread بلاک بشه تا اجرا بشن:</p>
<pre><code class="language-rust ignore">fn main() {
    let song = block_on(learn_song());
    block_on(sing_song(song));
    block_on(dance());
}
</code></pre>
<p>با این حال با از کل توان و سرعتمون تو این روشن استفاده نکردیم برای اینکه فقط یک کار رو در لحظه داریم انجام میدیم!
مشخصه که ما اول باید یاد بگیریم چجوری آهنگ بخونیم <code>learn_song</code> که بعدش واقعا بتوینم بخونیمش <code>sing_song</code>، ولی این شدنیه که طی یادگرفتن و خوندن آهنگ همزمان برقصیم <code>dance</code>. برای این کار میتونیم دو تا تابع <code>async fn</code> مستقل بسازیم که به صورت همزمان اجرا بشن:</p>
<pre><code class="language-rust ignore">async fn learn_and_sing() {
    // اینجا اول صبر میکنیم آهنگ یاد گرفته بشه قبل از خوندنش
    // انیجا ما از &quot;اویت&quot; به جای &quot;بلاک آن&quot; استفاده میکنیم تا جلوگیری
    // بشه از بلاک شدن و مسدود شدن ترد اینجوری میتونیم همزمان با این کار
    // تابع رقصیدن هم اجرا کنیم
    let song = learn_song().await;
    sing_song(song).await;
}

async fn async_main() {
    let f1 = learn_and_sing();
    let f2 = dance();

    // ماکرو &quot;جوین&quot; مثل &quot;اویت&quot; هست. با استفاده از این ماکرو میشه
    // برای تموم شدن چندین &quot;فیوچر&quot; به صورت همزمان صبر کرد.
    // اگه به صورت موقت تابع اولی ترد رو بخواد مسدود کنه کار تابع بعدی یعنی رقصیدن انجام میشه.
    // و برعکسش هم میتونه اتفاق بیفته، یعنی اگه رقصیدن بخواد مسدود بشه اون یکی تابع اجرا میشه
    // و اگه جفتشون بلاک بشن این فانکشن کلا بلاک میشه و اجراکنندش صبر میکنه تموم بشه کارش
    futures::join!(f1, f2);
}

fn main() {
    block_on(async_main());
}
</code></pre>
<p>توی این مثال، یاد گرفتن آهنگ <code>learn_song</code> باید قبل از خوندنش <code>sing_song</code> انجام بشه، ولی هر دو کار یادگرفتن و خوندن میتونه همزمان با رقصیدن <code>dance</code> اتفاق بیفته. اگه ما داخل <code>learn_and_sing</code> به جای <code>learn_song().await</code> از <code>block_on(learn_song())</code> استفاده کرده بودیم، توی thread هیچ کاره دیگه ای نمیشد انجام بدیم وقتی <code>learn_song</code> اجرا میشد.
که همین باعث میشد نتونیم همزمان با اون کارها برقصیم <code>dance</code>. با استفاده از <code>.await</code> روی <code>learn_song</code> که از نوع future بود، این اجازه رو به thread دادیم که به کار بقیه task ها و عملیات برسه اگه <code>learn_song</code> بلاک شده بود. با این روش این امکان فراهم شد تا چندین future به صورت همزمان توی یک thread کارشون تموم شه و به پایان برسن.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="زیر-و-بم-اجرای-کد-های-async-با-future"><a class="header" href="#زیر-و-بم-اجرای-کد-های-async-با-future">زیر و بم اجرای کد های Async با Future</a></h1>
<p>تو این فصل، نگاهی میندازیم به زیرساخت نحوه اولیوت بندی اجرای <code>Future</code> و task ها و عملیات Async.
اگه علاقه ای به زیرساخت و نحوه اجرای کد ها و تایپ های <code>Future</code> ندارید و فقط میخواید کد های سطح بالای <code>Future</code> بنویسید و با اونا کار کنید میتونید این فصل رو رد کنید و برید سراغ فصل <code>async</code>/<code>await</code>. البته خیلی از مباحثی که توی این فصل راجبش بحث میکنیم
به درک ما از نحوه کار کد <code>async</code>/<code>await</code> کمک میکنه، مثل نحوه کار runtime ها و قسمت های کلیدی از نظر سرعت و عملکرد کد Async.
به هر حال اگه تصمیم گرفتید این فصل رو رد کنید، یادتون باشه bookmark اش کنید تا یه وقتی تو آینده حتما بهش سر بزنید و مطالعش کنید.</p>
<p>خب، پس بدون معطلی بریم سراغ trait ای قراره راجبش صحبت کنیم، یعنی <code>Future</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="نگاه-دقیق-به-future-trait"><a class="header" href="#نگاه-دقیق-به-future-trait">نگاه دقیق به Future Trait</a></h1>
<p>trait <code>Future</code> در Rust هسته مرکزیه برنامه نویسی Async محسوب میشه.
<code>Future</code> یک محاسبه Async هست که در نهایت یک مقداری رو تولید میکنه.(که البته ممکنه اون مقدار خالی باشه مثل <code>()</code>). یک مثال <em>آسون شده</em> از trait <code>Future</code> میتونه این شکلی باشه:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait SimpleFuture {
    type Output;
    fn poll(&amp;mut self, wake: fn()) -&gt; Poll&lt;Self::Output&gt;;
}

enum Poll&lt;T&gt; {
    Ready(T),
    Pending,
}
<span class="boring">}
</span></code></pre></pre>
<p>Future ها میتونن با استفاده از صدا زدن تابع <code>poll</code> اجرا بشن، که این باعث میشه Future رو همینجور به سمتی سوق بده که بالاخره اجراش تکمیل بشه.
اگه Future تموم بشه مقدار <code>Poll::Ready(result)</code> رو برمیگردونه. اگه Future هنوز آماده نیست و تکمیل نشده باشه مقدار <code>Poll::Pending</code> رو برمیگردونه و هر وقت Future آماده باشه تا پردازش بیشتری رو جلو ببره تابع <code>wake()</code> رو صدا میزنه.
وقتی <code>wake()</code> صدا زده بشه، اون اجراکننده ای که داره <code>Future</code> رو انجام میده دوباره <code>poll</code> رو صدا میزنه تا <code>Future</code> بتونه پزدازششو جلو ببره.</p>
<p>بدون <code>wake()</code> اون اجراکننده هیچ اطلاعی نداره که یه Future خاص میتونه ادامه پردازششو انجام بده، و باید به صورت مداوم همه future ها رو poll بگیره. با تابع <code>wake()</code> اجراکننده دقیقا میدونه کدوم future آماده هست تا <code>poll</code> گرفته بشه.</p>
<p>برای مثال فرض کنیید قراره از یک socket دیتایی رو بخونیم که هنوز آماده نیست. اگه دیتا آماده باشه میتونیم بخونیمش و مقدار <code>Poll::Ready(data)</code> ولی اگه دیتایی آماده نباشه future ما بلاک و مسدود میشه و نمیتونم پردازش رو جلو ببریم. وقتی دیتایی آماده نباشه ما باید یک <code>wake</code> رو ثبت کنیم یا به اصطلاح register کنیم تا وقتی دیتا socket آماده بود اونو صدا بزنیم، که این کار باعث میشه به اجراکننده کدمون این پیغامو برسونه که future آماده ادامه پردازششه. یه مثال ساده از <code>SocketRead</code> میتونه چیزی شبیه به مثال زیر باشه:</p>
<pre><code class="language-rust ignore">pub struct SocketRead&lt;'a&gt; {
    socket: &amp;'a Socket,
}

impl SimpleFuture for SocketRead&lt;'_&gt; {
    type Output = Vec&lt;u8&gt;;

    fn poll(&amp;mut self, wake: fn()) -&gt; Poll&lt;Self::Output&gt; {
        if self.socket.has_data_to_read() {
            // سوکت دیتا رو آماده داره -- بخونش داخل یه بافر و برگردونش
            Poll::Ready(self.socket.read_buf())
        } else {
            // سوکت هنوز دیتایی نداره
            //
            // تابع &quot;بیدار شدن&quot; رو زمانی که دیتا آماده بود صدا بزن.
            // وقتی دیتا آماده باشه تابع &quot;بیدار شدن&quot; صدا زده میشه و در نتیجه
            // اون &quot;فیوچر&quot; میدونه که الان باید &quot;پول&quot; رو صدا بزنه دوباره و دیتا رو بگیره
            self.socket.set_readable_callback(wake);
            Poll::Pending
        }
    }
}
</code></pre>
<p>این مدل از <code>Future</code> ها امکان ترکیب چندین عملیات async رو بدون نیاز به allocate کردن state های اضافی فراهم می کنند.
اجرا کردن چندین Future به صورت یکجا یا به صورت زنجیره ای از Future ها میتونه بدون نیاز به allocation های اضافی state های مربوطه به صورت زیر پیاده سازی بشه:</p>
<pre><code class="language-rust ignore">/// یک &quot;فیوچر ساده&quot; که دو تا تابع &quot;فیوچر&quot; دیگه رو اجرا میکنه تا همزمان تموم بشن
/// 
/// همزمانی در اینجا با استفاده از صدا کردن &quot;پول&quot; روی تک تک &quot;فیوچر&quot; ها
/// انجام میشه، که این اجازه رو میده که اگر &quot;فیوچر&quot;ی خواست میتونه دیگه اجرا نشه و بقیه
/// اجرا بشن و در واقع هر &quot;فیوچر&quot;ی با سرعت خودش اجرا بشه
pub struct Join&lt;FutureA, FutureB&gt; {
    // هر کدوم از فیلد ها زیر ممکنه توشون &quot;فیوچر&quot; ی باشه که باید اجرا شه
    // اگر &quot;فیوچرز&quot; تکمیل شده باشه مقدار فیلد به &quot;نان&quot; تغییر پیدا میکنه
    // که این باعث میشه ما &quot;فیوچر&quot; هایی که تکمیل شدن رو دوباره اجرا نکنیم و &quot;پول&quot; نگیریم
    a: Option&lt;FutureA&gt;,
    b: Option&lt;FutureB&gt;,
}

impl&lt;FutureA, FutureB&gt; SimpleFuture for Join&lt;FutureA, FutureB&gt;
where
    FutureA: SimpleFuture&lt;Output = ()&gt;,
    FutureB: SimpleFuture&lt;Output = ()&gt;,
{
    type Output = ();
    fn poll(&amp;mut self, wake: fn()) -&gt; Poll&lt;Self::Output&gt; {
        // سعی کن &quot;فیوچر&quot; اول رو انجلم بدی
        if let Some(a) = &amp;mut self.a {
            if let Poll::Ready(()) = a.poll(wake) {
                self.a.take();
            }
        }

        // سعی کن &quot;فیوچر&quot; بعدی رو انجام بدی
        if let Some(b) = &amp;mut self.b {
            if let Poll::Ready(()) = b.poll(wake) {
                self.b.take();
            }
        }

        if self.a.is_none() &amp;&amp; self.b.is_none() {
            // هر دوی &quot;فیوچر&quot; ها با موفقیت تموم شدن -- حالا میتونیم با موفقیت نتیجه رو برگردونیم
            Poll::Ready(())
        } else {
            // یک یا هر دوی &quot;فیوچر&quot; ها آماده نیست و هنوز کار دارن تا تموم بشن
            // اونا تابع &quot;بیدار شدن&quot; رو زمانی که بتونن پردازشی رو جلو ببرن صدا میزنن
            Poll::Pending
        }
    }
}
</code></pre>
<p>این نشون دهنده اینه که چندین Future میتونن به صورت همزمان اجرا بشن بدون نیاز به allocation های جداگانه، که همین باعث میشه برنامه های async با بازده بیشتر رو بتونیم بسازیم.
مشابه همین داستان، چندین Future میتونن به صورت خطی پشت سر هم اجرا بشن، مثل مثال زیر:</p>
<pre><code class="language-rust ignore">/// یک &quot;فیچوچر&quot; دیگه که دو تا &quot;فیوچر&quot; رو انجام میده، یکی بعد از اونی یک و پشت سر هم
//
// نکته: برای اهداف این مثال هر دوی &quot;فیوچر&quot; ها در لحظه ساختن در دسترس هستن
// در واقعیت خروجی &quot;فویچر&quot; دوم میتونه به عنوان ورودی به &quot;فیوچر&quot; بعدئی منتقل شه
pub struct AndThenFut&lt;FutureA, FutureB&gt; {
    first: Option&lt;FutureA&gt;,
    second: FutureB,
}

impl&lt;FutureA, FutureB&gt; SimpleFuture for AndThenFut&lt;FutureA, FutureB&gt;
where
    FutureA: SimpleFuture&lt;Output = ()&gt;,
    FutureB: SimpleFuture&lt;Output = ()&gt;,
{
    type Output = ();
    fn poll(&amp;mut self, wake: fn()) -&gt; Poll&lt;Self::Output&gt; {
        if let Some(first) = &amp;mut self.first {
            match first.poll(wake) {
                // ما اولین &quot;فیوچر&quot; رو انجام دادیم -- پاکش کن
                // و دومی رو شروع کن
                Poll::Ready(()) =&gt; self.first.take(),
                // ما هنوز نمیتونیم اولین &quot;فیوچر&quot; روو انجام بدیم
                Poll::Pending =&gt; return Poll::Pending,
            };
        }
        // حالا که اولین &quot;فیوچر&quot; تموم شده، سعی کن دومی رو انجام بدی
        self.second.poll(wake)
    }
}
</code></pre>
<p>این مثال ها نشون میده چطوری trait <code>Future</code> میتونه بیان های مختلفی از جریان کنترلی روی یه برنامه async رو بدون نیاز به allocate کردن چندین object و callback های تو در تو ارائه بده.
با این تفاسیر بیاید راجب trait اصلی <code>Future</code> و تفاوت هاش صحبت کنیم:</p>
<pre><code class="language-rust ignore">trait Future {
    type Output;
    fn poll(
        // به تغییر تایپ این مقدار پایین دقیت کنید
        self: Pin&lt;&amp;mut Self&gt;,
        // تایپ مقدار پایین هم عوض شده
        cx: &amp;mut Context&lt;'_&gt;,
    ) -&gt; Poll&lt;Self::Output&gt;;
}
</code></pre>
<p>اولین چیزی که احتمالا متوجهش شدید اینه که <code>self</code> دیگه از نوع <code>&amp;mut Self</code> نیست و تبدیل شده به <code>Pin&lt;&amp;mut Self&gt;</code>.
ما راجب <a href="02_execution/../04_pinning/01_chapter.html">Pin کردن</a> بیشتر در اینده صحبت میکنم، ولی فعلا در همین حد بدونید که Pin کردن این اجازه رو به ما میده تا Future های غیر قابل حرکت (ثابت) بسازیم. Object های ثابت یا غیر قابل حرکت میتونن Pointer مربوط به مقادیرشون رو بین همون مقادیر ذخیره کنن مثلا
<code>struct MyFut { a: i32, ptr_to_a: *const i32 }</code>. Pin کردن یه چیز واجب برای استفاده از async/await هست.</p>
<p>در ادامه میبینم که <code>wake: fn()</code> تبدیل شده به <code>&amp;mut Context&lt;'_&gt;</code>. در <code>SimpleFuture</code> ما یک تابع pointer (<code>fn()</code>) رو صدا میزدیم تا به اون اجراکننده Future بگیم اون Future ای که نیاز داریم رو poll بگیره یا وضعیتشو چک کنه.
با این وجود، چون <code>fn()</code> فقط یه تابع pointer هست، نمیتونه هیچ اطلاعاتی راجب اینکه <em>کدوم</em> <code>Future</code> تابع <code>wake</code> رو صدا زده ذخیره کنه.</p>
<p>توی یک نرم افزار واقعی که قراره ساخته بشه، یه برنامه پیچیده مثل یک وب سرور شاید هزاران کانکشن داره که اون کانکشن ها باید توابع wake up شون به صورت جداگانه همگی صدا زده بشه. تایپ <code>Context</code> این مشکل رو با استفاده از تایپ <code>Waker</code> و دسترسی به اون حل کرده، که در حقیقت میتونه باهاش یه task خاص و مشخص رو صدا بزنه و wake up اش کنه.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="بیدار-کردن-یک-عملیات-async-با-waker"><a class="header" href="#بیدار-کردن-یک-عملیات-async-با-waker">بیدار کردن یک عملیات Async با Waker</a></h1>
<p>این خیلی عادیه که Future ها همون بار اولی که poll میشن قادر به اتمام کارشون نباشن.
تو این موقعیت، Future باید اطمیانان حاصل کنه که در آینده دوباره poll میشه وقتی آمادس تا پردازش بیشتری رو جلو ببره.
این کار با استفاده از تایپ <code>Waker</code> انجام میشه.</p>
<p>هر زمانی که یه Future poll میشه، به عنوان قسمتی از یک کارواحد یا &quot;task&quot; poll میشه. task ها همون Future های سطح بالایی هستن که به یک اجراکننده داده شدن تا اجرا بشن.</p>
<p><code>Waker</code> یه متد <code>wake()</code> داره که کارش اینه که به اجرا کننده بگهئ task ای که بهش وصل شده رو صدا بزنه یا به اصطلاح بیدارش کنه. وقتی <code>wake()</code> وقتی <code>wake()</code> صدا زده میشه اجراکننده میدونه task ای که به <code>Waker</code> متصل شده آمادس تا پردازش بیشتری رو انجام بده و Future اون باید دوباره poll بشه.</p>
<p><code>Waker</code> متد <code>clone()</code> هم پیاده سازی کرده که میتونه تو جاهای مختلف کپی و ذخیره بشه.</p>
<p>خب حالا بیاید سعی کنیم یه تایمر ساده Future با استفاده از <code>Waker</code> بسازیم:</p>
<h2 id="مثال-عملی-یک-تایمر-بسازید"><a class="header" href="#مثال-عملی-یک-تایمر-بسازید">مثال عملی: یک تایمر بسازید</a></h2>
<p>برای درک بهتر این مثال، وقتی تایمر درست شد ما میایم یک thread جدید ایجاد میکنیم و برای مدتی که اون تایمر ست شده thread رو تو حالت sleep میبریم و بعد از اون یه signal به تایمر Future میدیم که متوجه بشه تایم به اتمام رسیده.</p>
<p>اول، یه پروژه جدید با دستور <code>cargo new --lib time_future</code> ایجاد کنید و چیزایی که لازم داریم رو به <code>src/lib.rs</code> اضافه کنید:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::{
    future::Future,
    pin::Pin,
    sync::{Arc, Mutex},
    task::{Context, Poll, Waker},
    thread,
    time::Duration,
};
<span class="boring">}
</span></code></pre></pre>
<p>بیاین اول از تعریف کردن خود تایپ Future شروع کنیم. Future ما نیاز به یک راهی داره تا بتونه با thread ارتباط برقرار کنه و متوجه تموم شدن تایم در اون thread بشه و در نهایت Future کارش با موفقت به اتمام برسه. برای این کار از <code>Arc&lt;Mutex&lt;..&gt;&gt;</code> برا ذخیره مقادیرمون استفاده میکنیم تا بتونیم از طریق اون بین Future و thread مون ارتباط برقرار کنیم.</p>
<pre><code class="language-rust ignore">pub struct TimerFuture {
    shared_state: Arc&lt;Mutex&lt;SharedState&gt;&gt;,
}

/// وضعیت اشتراکی بین &quot;فیوچر&quot; و &quot;ترد&quot; ی که منتظر وایساده
struct SharedState {
    /// این مقدار نشون میده که تایمر کارش تموم شده یا نه
    completed: bool,

    /// تابع &quot;بیدار شونده&quot; برای این تایمر. که وقتی تایمر کارش تموم شد
    /// این تابع صدا زده بشه و ادامه عملیات انجام بشه
    waker: Option&lt;Waker&gt;,
}
</code></pre>
<p>حالا بیاین واقغا خود <code>Future</code> رو پیاده سازی کنیم!</p>
<pre><code class="language-rust ignore">impl Future for TimerFuture {
    type Output = ();
    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt; {
        // بررسی کن میکنه ببینه تایمر کارش تموم شده یا نه
        let mut shared_state = self.shared_state.lock().unwrap();
        if shared_state.completed {
            Poll::Ready(())
        } else {
            // تابع &quot;بیدار شونده&quot; رو ست میکنیم تا ترد بتونه
            // در زمانی که تایمر کارش تموم میشه اون صدا بزنه
            //
            // اینجا فقط یک بار عملیات کپی کردن از تابع &quot;بیدار شونده&quot; انجام میشه به جای
            // اینکه هر سری بیاد و کپی کنه
            //
            // البته میشه از تابع زیر هم برای بررسی اینکه آیا اون &quot;فیوچر&quot; بیدار میشه یا نه
            // هم استفاده کرد ولی برای اینکه مثال رو ساده نگه داریم اینجوری استفاده کردیم
            // `Waker::will_wake`
            shared_state.waker = Some(cx.waker().clone());
            Poll::Pending
        }
    }
}
</code></pre>
<p>خیلی راحت بود مگه نه ؟ اگه thread مقدار <code>shared_state.completed = true</code> رو ست کنه ما کارمون تمومه! در غیر این صورت میایم <code>Waker</code> رو clone برای task فعلی clone میکنیم به منتقلش میکنیم به <code>shared_state.waker</code>. به این ترتیب thread میتونه task رو دوباره بیدار کنه.</p>
<p>این خیلی مهمه که هر موقع که Future دوباره poll میشه ما <code>Waker</code> رو آپدیت کنیم، چون ممکنه Future یه task دیگه رو با یک <code>Waker</code> دیگه رو منتقل کرده باشه. این داستان زمانی اتفاق میفته که Future ها بین task های مختلف وقتی poll میشن جا به جا بشن.</p>
<p>در نهایت ما به یه API نیاز داریم تا واقعا تایمر رو بسازیم و thread رو شروع کنیم:</p>
<pre><code class="language-rust ignore">impl TimerFuture {
    /// یک &quot;فیوچر&quot; جدید درست میکنه زمانی که تایمر کارش انجام میشه
    pub fn new(duration: Duration) -&gt; Self {
        let shared_state = Arc::new(Mutex::new(SharedState {
            completed: false,
            waker: None,
        }));

        // یک ترد جدید میسازه
        let thread_shared_state = shared_state.clone();
        thread::spawn(move || {
            thread::sleep(duration);
            let mut shared_state = thread_shared_state.lock().unwrap();
            // زمانی که تایمر تموم شد یک سیگنال میفرسته و آخرین تسکی که &quot;پول&quot; شده رو بیدار میکنه
            // البته اگه تسکی موجود باشه
            shared_state.completed = true;
            if let Some(waker) = shared_state.waker.take() {
                waker.wake()
            }
        });

        TimerFuture { shared_state }
    }
}
</code></pre>
<p>این تمام چیزی بود که نیاز داشتیم تا یک تایمر Future ساده بسازیم. فقط کاش یه اجراکننده داشتیم که میتونستیم Future رو روی اون اجرا کنیم ...</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="پیاده-سازی-یک-اجراکننده-برای-عملیات-async"><a class="header" href="#پیاده-سازی-یک-اجراکننده-برای-عملیات-async">پیاده سازی یک اجراکننده برای عملیات Async</a></h1>
<p><code>Future</code> های Rust تنبل هستن: اونا هیچ کاری انجام نمیدن تا وقتی یکی اونا رو اجرا کنه تا اتمام پیدا کنن. یکی از راه ها برای اجرای یک Future اینه که از <code>.await</code> داخل یک تابع <code>async</code> استفاده کنیم، ولی خود این قضیه رو مشکل تر میکنه: حالا کی اون Future ای که توسط توابع <code>async</code> تولید شده رو اجرا میکنه ؟ جواب اینه که ما به یک اجرا کننده <code>Future</code> نیاز داریم.</p>
<p>اجارکننده های <code>Future</code> توابع سطح بالا <code>Future</code> رو میگیرم و اجراشون میکنن، که این کار رو با صدا زدن <code>poll</code> زمانی که <code>Future</code> میتونه پردازش بیشتری رو انجام بده، انجام میدن. معمولا اجراکننده های <code>poll</code> یک Future رو برای شروع صدا میزنن. وقتی Future میفهمه که آمادس تا پردازش بیشتری رو با صدا زدن <code>wake()</code> انجام بده، داخل یک صف گذاشته میشن تا دوباره نوبتشون بشه و <code>poll</code> دوباره صدا زده بشه، این کار اونقدر ادامه پیدا میکنه تا <code>Future</code> کارش تموم بشه.</p>
<p>تو این قسمت قراره اجراکننده ساده خودمون رو بنویسم که قادره تعداد زیادی توابع سطح بالا Future رو بگیره و به صورت همزمان اجرا کنه تا تموم بشن.</p>
<p>For this example, we depend on the <code>futures</code> crate for the <code>ArcWake</code> trait,
which provides an easy way to construct a <code>Waker</code>. Edit <code>Cargo.toml</code> to add
a new dependency:</p>
<p>برای این مثال ما از پکیج <code>futures</code> استفاده میکنیم تا بتونیم از trait <code>ArcWake</code> استفاده کنیم. چون خیلی راحت میتونیم یه <code>Waker</code> بسازیم. فایل <code>cargo.toml</code> رو باز کنید و این crate رو اضافه کنید:</p>
<pre><code class="language-toml">[package]
name = &quot;timer_future&quot;
version = &quot;0.1.0&quot;
authors = [&quot;XYZ Author&quot;]
edition = &quot;2021&quot;

[dependencies]
futures = &quot;0.3&quot;
</code></pre>
<p>در ادامه نیاز داریم تا این چیزا ها رو به بالای <code>src/main.rs</code> اضافه کنیم:</p>
<pre><code class="language-rust ignore">use futures::{
    future::{BoxFuture, FutureExt},
    task::{waker_ref, ArcWake},
};
use std::{
    future::Future,
    sync::mpsc::{sync_channel, Receiver, SyncSender},
    sync::{Arc, Mutex},
    task::Context,
    time::Duration,
};
// اون تایمری که توی قسمت قبل با هم نوشتیم
use timer_future::TimerFuture;
</code></pre>
<p>اجراکننده ما با ارسال task ها روی یک کانال (channel) کار میکنه. اجراکننده event ها رو از روی کانال بر میداره و اونا رو اجرا میکنه.
زمانی که یه task آماده هست تا کار بیشتری انجام بده (بیدار شده)، میتونه خودشو دوباره از طریق کانال بفرسته که دوباره poll بشه.</p>
<p>توی این طراحی، خود اجراکننده فقط لازمه قسمت دریافت کننده کانال رو داشته باشه. و کاربر باید قسمت فرستنده رو داشته باشه تا بتونه Future های جدید تولید کنه. Task ها خودشون فقط Future هایی هستن که میتونن دوباره خودشونو برنامه ریزی کنن برای اجرا دوباره، پس با اونا رو به صورت جفت Future با فرستنده ذخیره میکنیم تا task بتونه دوباره خودشو توی صف بزاره.</p>
<pre><code class="language-rust ignore">/// اجراکننده ای که تسک ها رو از یه کانال میگیره و اجراشون میکنه
struct Executor {
    ready_queue: Receiver&lt;Arc&lt;Task&gt;&gt;,
}

/// این یه &quot;فیوچر&quot; جدید میسازه و میفرسته به کانال
#[derive(Clone)]
struct Spawner {
    task_sender: SyncSender&lt;Arc&lt;Task&gt;&gt;,
}

/// یک &quot;فیوچر&quot; ی که میتونه خودشو دوباره برنامه ریزی که که توسط اجراکننده دوباره &quot;پول&quot; بشه
struct Task {
    /// فیوچری که در حاله پردازشه و باید به داخل صف گذاشته بشه تا انجام بشه
    /// 
    /// اینجا استفاده از &quot;میوتکس&quot; اجباری نیست، به دلیل اینکه ما فقط از طریق یک &quot;ترد&quot; داریم به مقادریمون دسترسی
    /// پیدا میکنیم، اما &quot;راست&quot; اونقدر باهوش نیست که بفهمه ما فقط از یه &quot;ترد&quot; استفاده میکنیم
    /// برای همین مجبوریم از &quot;میتوکس&quot; استفاده کنیم تا قوانین امن بودن مموری در
    /// زبان &quot;راست&quot; رو رعایت کرده باشیم
    /// البته میشه از تایپ زیر هم به جای میتوکس استفاده کرد
    /// `UnsafeCell`
    future: Mutex&lt;Option&lt;BoxFuture&lt;'static, ()&gt;&gt;&gt;,

    /// یک هندلر که تسک رو برنامه ریزی میکنه و برش میگردونه به داخل صف
    task_sender: SyncSender&lt;Arc&lt;Task&gt;&gt;,
}

fn new_executor_and_spawner() -&gt; (Executor, Spawner) {
    // بیشترین حد تسک هایی که میتونیم داخل صف داشته باشیم از طریق کانال در یک لحظه
    const MAX_QUEUED_TASKS: usize = 10_000;
    let (task_sender, ready_queue) = sync_channel(MAX_QUEUED_TASKS);
    (Executor { ready_queue }, Spawner { task_sender })
}
</code></pre>
<p>بیاید یه متد هم برای راحتی تولید Future های جدید بسازیم.
این متد یک تایپ Future میگیره که ما اینو با تایپ box یکی میکنیم و یک <code>Arc&lt;Task&gt;</code> جدید میسازیم که میتونه داخل اجراکننده به صورت صف اجرا بشه.</p>
<pre><code class="language-rust ignore">impl Spawner {
    fn spawn(&amp;self, future: impl Future&lt;Output = ()&gt; + 'static + Send) {
        let future = future.boxed();
        let task = Arc::new(Task {
            future: Mutex::new(Some(future)),
            task_sender: self.task_sender.clone(),
        });
        self.task_sender.send(task).expect(&quot;too many tasks queued&quot;);
    }
}
</code></pre>
<p>برای poll کردن Future ها باید یه <code>Waker</code> بسازیم.
همونطور که داخل <a href="02_execution/./03_wakeups.html">بیدار کردن یک عملیات Async با Waker</a> بحث کریدم، <code>Waker</code> ها موظف هستن که یک task رو برنامه ریزی کنن برای poll شدن دوباره وقتی <code>wake</code> صدا زده میشه. یادتون باشه که <code>Waker</code> به اجراکننده میگه که دقیقا چه task ای آماده هست، که همین باعث میشه فقط Future های poll بشن که آماده هستن تا پردازش بیشتری رو انجام بدن. راحت ترین راه برای ساختن یک <code>Waker</code> پیاده سازی trait <code>ArcWake</code> و بعد استفاده از توابع <code>waker_ref</code> یا <code>.into_waker()</code> هست تا بتونیم <code>Arc&lt;impl ArcWake&gt;</code> رو به <code>Waker</code> تبدیل کنیم.
بیاید <code>ArcWake</code> رو برای task هامون پیاده سازی کنیم تا این اجازه رو بهشون بدیم که به <code>Waker</code> تبدیل بشن و در نهایت بیدار بشن:</p>
<pre><code class="language-rust ignore">impl ArcWake for Task {
    fn wake_by_ref(arc_self: &amp;Arc&lt;Self&gt;) {
        // تابع &quot;بیدار کننده&quot; رو با فرستادن تسک توی کانال پیاده سازی میکنیم
        // تا دوباره توسط اجرا کننده &quot;پول&quot; بشه
        let cloned = arc_self.clone();
        arc_self
            .task_sender
            .send(cloned)
            .expect(&quot;too many tasks queued&quot;);
    }
}
</code></pre>
<p>وقتی یک <code>Waker</code> از <code>Arc&lt;Task&gt;</code> ساخته میشه، صدا کردن <code>wake()</code> باعث میشه یک کپی از <code>Arc</code> به کانال task ها فرستاده بشه. در نهایت اجارکننده ما باید task رو برداره و poll اش کنه. بیاید همینو پیاده سازی کنیم:</p>
<pre><code class="language-rust ignore">impl Executor {
    fn run(&amp;self) {
        while let Ok(task) = self.ready_queue.recv() {
            // فیوچر رو میگیره و اگه هنوز تکمیل نشده باشه &quot;پول&quot; اش میکنه
            // و سعی میکنه تکمیلش کنه
            let mut future_slot = task.future.lock().unwrap();
            if let Some(mut future) = future_slot.take() {
                // یک &quot;بیدار شونده&quot; از خود تسک میسازیم
                let waker = waker_ref(&amp;task);
                let context = &amp;mut Context::from_waker(&amp;*waker);
                // `BoxFuture&lt;T&gt;` این تایپ یه تایپ مستعار برای تایپ زیره
                // `Pin&lt;Box&lt;dyn Future&lt;Output = T&gt; + Send + 'static&gt;&gt;`.
                if future.as_mut().poll(context).is_pending() {
                    // ایمنجا هنوز تسک ما تکمیل نشده برای همین
                    // دوباره برش میگردونیم تا دوباره توسط اجراکننده اجرا بشه
                    *future_slot = Some(future);
                }
            }
        }
    }
}
</code></pre>
<p>تبریک میگم! ما الان یک اجراکننده Future داریم که کار میکنه. حتی الا میتونیم با این اجارکننده عملیات <code>asyn/.await</code> و Future های شخصی سازی شده رو انجام بدیم. عملیاتی مثل <code>TimeFuture</code> که قبلا نوشتیمش:</p>
<pre><code class="language-rust edition2018 ignore">fn main() {
    let (executor, spawner) = new_executor_and_spawner();

    //یک تسک برای پرینت کردن قبل و بعد از اتمام تایمر میسازیم
    spawner.spawn(async {
        println!(&quot;howdy!&quot;);
        // صبر میکنیم تا تایمر &quot;فیوچر&quot; ما بعد از 2 ثانیه تکمیل بشه
        TimerFuture::new(Duration::new(2, 0)).await;
        println!(&quot;done!&quot;);
    });

    // حالا از حافظه پاکش میکنیم تا اجرا کننده بدونه تموم شده کارش
    // و تسک های بیشتری در آینده نمیگیره ازش تا اجراش کنه
    drop(spawner);

    // Run the executor until the task queue is empty.
    // This will print &quot;howdy!&quot;, pause, and then print &quot;done!&quot;.
    // اجرا کننده رو اجرا میکنه تا زمانی که صف تسک ها خالی بشه
    // که در نهایت برای ما اول پرینت میکنه:
    // &quot;howdy!&quot;
    // و بعدش پرینت میکنه
    // &quot;done!&quot;
    executor.run();
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="اجراکننده-ها-و-io-سیستم"><a class="header" href="#اجراکننده-ها-و-io-سیستم">اجراکننده ها و IO سیستم</a></h1>
<p>توی قسمت قبلی در بخش <a href="02_execution/./02_future.html">نگاه دقیق به Future Trait</a> راجب این مثال از خوندن socket به صورت async که یک Future بود بحث کردیم:</p>
<pre><code class="language-rust ignore">pub struct SocketRead&lt;'a&gt; {
    socket: &amp;'a Socket,
}

impl SimpleFuture for SocketRead&lt;'_&gt; {
    type Output = Vec&lt;u8&gt;;

    fn poll(&amp;mut self, wake: fn()) -&gt; Poll&lt;Self::Output&gt; {
        if self.socket.has_data_to_read() {
            // سوکت دیتا رو آماده داره -- بخونش داخل یه بافر و برگردونش
            Poll::Ready(self.socket.read_buf())
        } else {
            // سوکت هنوز دیتایی نداره
            //
            // تابع &quot;بیدار شدن&quot; رو زمانی که دیتا آماده بود صدا بزن.
            // وقتی دیتا آماده باشه تابع &quot;بیدار شدن&quot; صدا زده میشه و در نتیجه
            // اون &quot;فیوچر&quot; میدونه که الان باید &quot;پول&quot; رو صدا بزنه دوباره و دیتا رو بگیره
            self.socket.set_readable_callback(wake);
            Poll::Pending
        }
    }
}
</code></pre>
<p>این Future دیتای موجود socket رو میخونه، و اگر دیتای برای خوندن موجود نباشه، به اجراکننده میگه، و ازش میخواد که task هاش صدا زده بشن یا دوباره بیدار بشن در زمانی که دیتایی برای خوندن موجود باشه. با این حال، توی این مثال واضح نیست که تایپ <code>Socket</code> چجوری
پیاده سازی شده یا به صورت دقیق تر، مشخص نیست که تابع <code>set_readable_callback</code> چجوری کار میکنه.
چجوری میتونیم <code>wake()</code> رو فراخونی کنیم زمانی که socket چیزی برای خوندن داشته باشه ؟ یه راه حل اینه که یک thread به صورت مداوم چک کنه که آیا <code>socket</code> دیتایی برای خوندن داره یا نه و در زمان مناسب <code>wake()</code> رو فراخونی کنه. البته این روش اصلا بهینه نیست، چون داریم برای هر IO ای که مسدود کننده (blocking) هست یک thread باز میکنیم. این روش باعث میشه کارآمدی کد async ما خیلی پایین باشه.</p>
<p>در واقعیت، این مشکل با یک سری کتابخونه هایی که به اصطلاح آگاه به IO مسدود کننده سیستم هستن حل شده، مثل <code>epoll</code> روی لینوکس، <code>kqueue</code> روی FreeBSD و MacOS، IOCP روی ویندوز و <code>port</code> رو Fuchsia همه ی اینا داخل Rust از طریق crate ای به نام <a href="https://github.com/tokio-rs/mio"><code>mio</code></a> که به صورت cross platform دسترسی به این کتابخونه های سیستمی رو فراهم میکنه به صورت آماده وجود داره. این کتابخونه ها این امکان رو فراهم میکنن که یک thread رو چندین عملیات IO async مسدود بشه و زمانی نتیجش برگرده که یکی از اون event ها انجام شده و نتیجش حاضره. تو عمل استفاده از API این کتابخونه ها یه چیزی شبیه مثال زیره:</p>
<pre><code class="language-rust ignore">
struct IoBlocker {
    /* ... */
}

struct Event {
    // یک آی دی یکتا که مشخص کننده رویداد هست و با این آی دی لیست شده
    id: usize,

    // یک سری سیگنال که برای جوابشون صبر میکنه
    signals: Signals,
}

impl IoBlocker {
    /// ساخت یک کالکشن از عملیات ناهمزمان برای رویداد های &quot;آی او&quot; که برای گرفتن جوابشون ترد بلاک یا مسدود میشه
    fn new() -&gt; Self { /* ... */ }

    /// تعریف یک رویداد خاص برای بررسی در آینده
    fn add_io_event_interest(
        &amp;self,

        /// آبجکتی که رویداد توی اون اتفاق میفته
        io_object: &amp;IoObject,

        /// یک سری از سینگنال هایی که درون آبجکت بالا پدید میان
        /// که در نتیجه اون رویدادی باید اتفاق بیفته که اون رویداد با یک آی دی یکتا مشخص شده
        event: Event,
    ) { /* ... */ }

    /// بلاک شدن و مسدود شدن تا زمانی که یکی از رویداد ها اتفاق بیفته
    fn block(&amp;self) -&gt; Event { /* ... */ }
}

let mut io_blocker = IoBlocker::new();
io_blocker.add_io_event_interest(
    &amp;socket_1,
    Event { id: 1, signals: READABLE },
);
io_blocker.add_io_event_interest(
    &amp;socket_2,
    Event { id: 2, signals: READABLE | WRITABLE },
);
let event = io_blocker.block();

// اگر سوکت 1 زمانی قبال خوندن بشه برای مثال چاپ میشه: سوکت 1 آماده خوندن هست
println!(&quot;Socket {:?} is now {:?}&quot;, event.id, event.signals);
</code></pre>
<p>اجراکننده های Future میتونن از این کتابخونه های سیستمی استفاده کنن تا امکان اجرا شدن callback این Object های IO async مثل socket ها موقعی که event مربوطه اتفاق میفته فراهم بشه.
توی مثال مربوط به <code>SocketRead</code> در بالا، تابع <code>Socket::set_readable_callback</code> یه چیزی شبیه کد پایینه:</p>
<pre><code class="language-rust ignore">impl Socket {
    fn set_readable_callback(&amp;self, waker: Waker) {
        // یک رفرنس از اجراکننده ای که قرار اجرا کنه
        // که البته خیلیا این رو به صورت کلی داخل اون تردی که قراره اجرا بشه میارن
        // اما اینجا یک رفرنس از اون پاس داده شده تا از این رفرنس استفاده بشه
        let local_executor = self.local_executor;

        // یک ای دی یکتا برای این آبجکت آی او
        let id = self.id;

        // تابع بیدارکننده رو توی مپ اجراککنده ذخیره میکنیم تا بعدا وقت رویداد های آی او
        // اتفاق افتادن بتونه صداشون بزنه
        local_executor.event_map.insert(id, waker);
        local_executor.add_io_event_interest(
            &amp;self.socket_file_descriptor,
            Event { id, signals: READABLE },
        );
    }
}
</code></pre>
<p>حالا ما میتونیم فقط یک اجراکننده روی thread داشته باشیم تا رویداد ها و event های IO رو بگیره و <code>Waker</code> متناسب با اون رو فعال کنه، که باعث میشه task مربوطه انجام بشه. همین مساله باعث میشه که اجراکننده فرصت داشته باشه تا task های بیشتری رو اجرا کنه قبل از اینکه دوباره بره و چک کنه event جدید IO ای برای اجرا کردن داره یا نه (و این چرخه همینجور ادامه داره ...).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="asyncawait"><a class="header" href="#asyncawait"><code>async</code>/<code>.await</code></a></h1>
<p>توی <a href="03_async_await/../01_getting_started/04_async_await_primer.html">فصل اول</a> نگاه کوتاهی به ‍‍<code>async</code>/<code>.await</code> داشتیم.
توی این فصل با جزئیات بیشتری روی <code>async</code>/<code>.await</code> بحث میکنیم و میبینم چجوری کد async با کد عادی که قبلا تو Rust میدیدیم فرق داره.</p>
<p><code>async</code>/<code>.await</code> کلیدواژه های ویژه ای هستند که قدرت برنامه نویسی async رو به Rust میدن و اجازه میدن قدرت به thread برگرده و عملیات بعدی رو انجام بده در حالی که منتظر جواب یه کد async هست.</p>
<p>دو راه اصلی برای استفاده از <code>async</code> وجود داره: یکی <code>async fn</code> و اون یکی بلاک های <code>async</code> هستن.
که هر کدوم مقداری رو بر میگردونن که trait ‍‍<code>‍‍Future</code> رو پیاده سازی کرده.</p>
<pre><code class="language-rust edition2018 ignore">
// تابع زیر تایپی رو برمیگردونه که &quot;تریت&quot; زیر رو پیاده سازی کرده:
// `Future&lt;Output = u8&gt;`
// که باعث میشه در نهایت تایپ زیر برگرده:
// u8
async fn foo() -&gt; u8 { 5 }

fn bar() -&gt; impl Future&lt;Output = u8&gt; {
    // بلاک زیر تایپی رو برمیگردونه از نوع:
    // `Future&lt;Output = u8&gt;`
    async {
        let x: u8 = foo().await;
        x + 5
    }
}
</code></pre>
<p>همونطور که توی فصل اول دیدیم بدنه <code>async</code> و بقیه Future ها تنبل هستن:
به این معنی که تا زمانی که اجرا نشن هیچ کاری نمیکنن. معمول ترین روش اجرا کردن <code>Future</code> اینه که منتظرش بمونید یا <code>.await</code> اش کنید.
زمانی که <code>.await</code> روی یه <code>Future</code> صدا زده میشه سعی میکنه اونو اجراش کنه تا با موفقیت تموم بشه. اگه <code>Future</code> بلاک کننده و مسدود کندده thread باشه کنترل رو به thread بر میگردونه. وقتی پردازش بیشتری میتونه انجام بشه <code>Future</code> دوباره توسط اجرا کننده برداشته میشه و ادامه پردازشش انجام میشه و این باعث میشه <code>.await</code> با موفقیت تکمیل بشه.</p>
<h2 id="lifetime-های-async"><a class="header" href="#lifetime-های-async">Lifetime های <code>async</code></a></h2>
<p>برعکس توابع معمول در Rust، توابع <code>async fn</code> ای که رفرنس ها یا آرگومان های غیر از <code>static</code> رو به عنوان ورودی میگیرن، <code>Future</code> ای بر میگردونن که lifetime شون دقیقا مثل lifetime آرگومان هاشون هست:</p>
<pre><code class="language-rust edition2018 ignore">// این تابع:
async fn foo(x: &amp;u8) -&gt; u8 { *x }

// با این تابع برابره:
fn foo_expanded&lt;'a&gt;(x: &amp;'a u8) -&gt; impl Future&lt;Output = u8&gt; + 'a {
    async move { *x }
}
</code></pre>
<p>که یعنی تابع <code>async fn</code> ای که یک Future بر میگردونه باید توسط <code>.await</code> صدا زده بشه در حالی که هنوز آرگومان های غیر <code>static</code> اش موجود هستن.
تو حالت عادی موقعی که <code>.await</code> میکنید بعد از اینکه تابع رو صدا میزنید مثلا مثل <code>foo(&amp;x).await</code> موردی به موجود نمیاد و مشکلی نیست.
با این حال، ذخیره کردن Future ها یا ارسالشون به یک task یا thread دیگه ممکنه مشکل ساز بشه.</p>
<p>یکی از کارهایی که برای تبدیل <code>asyn fn</code> با آرگومان هایی از جنس رفرنس به Future های <code>'static</code> میشه انجام داد، اینه که آرگومان ها رو با صدا کردن <code>async fn</code> داخل یک بلاک <code>async</code> جا بدیم:</p>
<pre><code class="language-rust edition2018 ignore">fn bad() -&gt; impl Future&lt;Output = u8&gt; {
    let x = 5;
    borrow_x(&amp;x) // ارور: مقدار &quot;ایکس&quot; زمان زیادی زنده نیست یعنی لایف تایمش اجازه نمیده
}

fn good() -&gt; impl Future&lt;Output = u8&gt; {
    async {
        let x = 5;
        borrow_x(&amp;x).await
    }
}
</code></pre>
<p>با انتقال آرگومان ها به بلاک <code>async</code>، lifetime اون رو بسط دادیم به lifetime اون <code>Future</code> ای که از صدا زدن <code>good</code> برمگیرده.</p>
<h2 id="async-move"><a class="header" href="#async-move"><code>async move</code></a></h2>
<p>بلاک های <code>async</code> و clouser مثل clouser های عادی اجازه استفاده از کلیدواژه <code>move</code> رو میده.
یه بلاک <code>async move</code> باعث میشه مالکیت تمام متغیر هایی که به عنوان رفرنس استفاده میشن رو بگیره و عمرشون دقیقا به اون scope محدود بشه که این قابلیت باعث میشه دیگه نشه ازشون تو قسمت های دیگه کد استفاده کرد:</p>
<pre><code class="language-rust edition2018 ignore">/// `async` block:
///
/// چندین بلاک از نوع زیر میتونن به متغیر های لوکال دسترسی داشته باشن
/// البته تا وقتی که تو اون اسکوپ اجرا بشن
async fn blocks() {
    let my_string = &quot;foo&quot;.to_string();

    let future_one = async {
        // ...
        println!(&quot;{my_string}&quot;);
    };

    let future_two = async {
        // ...
        println!(&quot;{my_string}&quot;);
    };

    // هر دو &quot;فیوچر&quot; اجرا میشه تا در نهایت دو بار مقدار زیر تپرینت میشه:
    // &quot;foo&quot;
    let ((), ()) = futures::join!(future_one, future_two);
}

/// `async move` block:
///
/// فقط یک بلاکی که کلیدواژه &quot;موو&quot; داره میتونه به مقادیر لوکال در لحظه دسترسی داشته باشه
/// به خاطر اینکه اون مقادیر به اسکوپ &quot;فیوچر&quot; منتقل شدن
/// البته همین باعث میشه اون &quot;فیوچر&quot; بیشتر از اسکوپ اصلی زنده بمونه و دووم بیاره:
fn move_block() -&gt; impl Future&lt;Output = ()&gt; {
    let my_string = &quot;foo&quot;.to_string();
    async move {
        // ...
        println!(&quot;{my_string}&quot;);
    }
}
</code></pre>
<h2 id="await-کردن-روی-یک-اجراکننده-multi-thread"><a class="header" href="#await-کردن-روی-یک-اجراکننده-multi-thread"><code>.await</code> کردن روی یک اجراکننده Multi-thread</a></h2>
<p>دقت کنید که وقتی از یک اجرا کننده <code>Future</code> به صورت Multi-thread استفاده میکنیم، <code>Future</code> ها میتونن بین thread ها منتقل بشن پس هم این Future ها هم متغیر ها باید امکان انتقال بین thread ها رو داشته باشن، چون هر درخواست <code>.await</code> میتونه منجر به تعویض thread بشه.</p>
<p>که این یعنی استفاده از <code>Rc</code> یا <code>&amp;RefCell</code> یا تایپ های دیگه ای که trait <code>Send</code> رو پیاده سازی نکردن و همچنین رفرنس هایی که به تایپ هایی اشاره دارن که trait <code>Sync</code> رو پیاده سازی نکردن، امن نیست.</p>
<p>(احتیاط: امکانش وجود داره از این تایپ ها استفاده کنید البته تا زمانی که توی scope ای که <code>.await</code> صدا زده میشه نباشن.)</p>
<p>به طور مشابه، ایده خوبی نیست مقادیر غیر Future ای lock شده رو توی <code>.await</code> ها استفاده کنید، چون باعث lock شدن یا قفل شدن thread pool میشه: مثلا ممکنه یه task باعث lock بشه و <code>.await</code> هم صدا زده بشه و قدرت کنترل برگرده به اجراکننده تا یه task دیگه انجام بشه که سعی کنه همون چیز رو lock کنه و همین باعث ایجاد deadlock بشه.
برای جلوگیری از این مشکل از تایپ <code>Mutex</code> داخل <code>future::lock</code> به جای <code>std::sync</code> استفاده کنید.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pinning"><a class="header" href="#pinning">Pinning</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="streams"><a class="header" href="#streams">Streams</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iteration-and-concurrency"><a class="header" href="#iteration-and-concurrency">Iteration and Concurrency</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="executing-multiple-futures-at-a-time"><a class="header" href="#executing-multiple-futures-at-a-time">Executing Multiple Futures at a Time</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="join"><a class="header" href="#join">join!</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="select"><a class="header" href="#select">select!</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="workarounds-to-know-and-love"><a class="header" href="#workarounds-to-know-and-love">Workarounds to Know and Love</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-in-async-blocks"><a class="header" href="#-in-async-blocks">? in async Blocks</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="send-approximation"><a class="header" href="#send-approximation">Send Approximation</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recursion"><a class="header" href="#recursion">Recursion</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="async-in-traits"><a class="header" href="#async-in-traits">async in Traits</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-async-ecosystem"><a class="header" href="#the-async-ecosystem">The Async Ecosystem</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="final-project-http-server"><a class="header" href="#final-project-http-server">Final Project: HTTP Server</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="running-asynchronous-code"><a class="header" href="#running-asynchronous-code">Running Asynchronous Code</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="handling-connections-concurrently"><a class="header" href="#handling-connections-concurrently">Handling Connections Concurrently</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing-the-server"><a class="header" href="#testing-the-server">Testing the Server</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
