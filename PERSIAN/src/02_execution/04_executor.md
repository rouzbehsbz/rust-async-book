# پیاده سازی یک اجراکننده برای عملیات Async

`Future` های Rust تنبل هستن: اونا هیچ کاری انجام نمیدن تا وقتی یکی اونا رو اجرا کنه تا اتمام پیدا کنن. یکی از راه ها برای اجرای یک Future اینه که از `.await` داخل یک تابع `async` استفاده کنیم، ولی خود این قضیه رو مشکل تر میکنه: حالا کی اون Future ای که توسط توابع `async` تولید شده رو اجرا میکنه ؟ جواب اینه که ما به یک اجرا کننده `Future` نیاز داریم.

اجارکننده های `Future` توابع سطح بالا `Future` رو میگیرم و اجراشون میکنن، که این کار رو با صدا زدن `poll` زمانی که `Future` میتونه پردازش بیشتری رو انجام بده، انجام میدن. معمولا اجراکننده های `poll` یک Future رو برای شروع صدا میزنن. وقتی Future میفهمه که آمادس تا پردازش بیشتری رو با صدا زدن `wake()` انجام بده، داخل یک صف گذاشته میشن تا دوباره نوبتشون بشه و `poll` دوباره صدا زده بشه، این کار اونقدر ادامه پیدا میکنه تا `Future` کارش تموم بشه.

تو این قسمت قراره اجراکننده ساده خودمون رو بنویسم که قادره تعداد زیادی توابع سطح بالا Future رو بگیره و به صورت همزمان اجرا کنه تا تموم بشن.

For this example, we depend on the `futures` crate for the `ArcWake` trait,
which provides an easy way to construct a `Waker`. Edit `Cargo.toml` to add
a new dependency:

برای این مثال ما از پکیج `futures` استفاده میکنیم تا بتونیم از trait `ArcWake` استفاده کنیم. چون خیلی راحت میتونیم یه `Waker` بسازیم. فایل `cargo.toml` رو باز کنید و این crate رو اضافه کنید:

```toml
[package]
name = "timer_future"
version = "0.1.0"
authors = ["XYZ Author"]
edition = "2021"

[dependencies]
futures = "0.3"
```

در ادامه نیاز داریم تا این چیزا ها رو به بالای `src/main.rs` اضافه کنیم:

```rust,ignore
{{#include ../../examples/02_04_executor/src/lib.rs:imports}}
```

اجراکننده ما با ارسال task ها روی یک کانال (channel) کار میکنه. اجراکننده event ها رو از روی کانال بر میداره و اونا رو اجرا میکنه.
زمانی که یه task آماده هست تا کار بیشتری انجام بده (بیدار شده)، میتونه خودشو دوباره از طریق کانال بفرسته که دوباره poll بشه.

توی این طراحی، خود اجراکننده فقط لازمه قسمت دریافت کننده کانال رو داشته باشه. و کاربر باید قسمت فرستنده رو داشته باشه تا بتونه Future های جدید تولید کنه. Task ها خودشون فقط Future هایی هستن که میتونن دوباره خودشونو برنامه ریزی کنن برای اجرا دوباره، پس با اونا رو به صورت جفت Future با فرستنده ذخیره میکنیم تا task بتونه دوباره خودشو توی صف بزاره.

```rust,ignore
{{#include ../../examples/02_04_executor/src/lib.rs:executor_decl}}
```

بیاید یه متد هم برای راحتی تولید Future های جدید بسازیم.
این متد یک تایپ Future میگیره که ما اینو با تایپ box یکی میکنیم و یک `Arc<Task>` جدید میسازیم که میتونه داخل اجراکننده به صورت صف اجرا بشه.

```rust,ignore
{{#include ../../examples/02_04_executor/src/lib.rs:spawn_fn}}
```

برای poll کردن Future ها باید یه `Waker` بسازیم.
همونطور که داخل [بیدار کردن یک عملیات Async با Waker] بحث کریدم، `Waker` ها موظف هستن که یک task رو برنامه ریزی کنن برای poll شدن دوباره وقتی `wake` صدا زده میشه. یادتون باشه که `Waker` به اجراکننده میگه که دقیقا چه task ای آماده هست، که همین باعث میشه فقط Future های poll بشن که آماده هستن تا پردازش بیشتری رو انجام بدن. راحت ترین راه برای ساختن یک `Waker` پیاده سازی trait `ArcWake` و بعد استفاده از توابع `waker_ref` یا `.into_waker()` هست تا بتونیم `Arc<impl ArcWake>` رو به `Waker` تبدیل کنیم.
بیاید `ArcWake` رو برای task هامون پیاده سازی کنیم تا این اجازه رو بهشون بدیم که به `Waker` تبدیل بشن و در نهایت بیدار بشن:

```rust,ignore
{{#include ../../examples/02_04_executor/src/lib.rs:arcwake_for_task}}
```

وقتی یک `Waker` از `Arc<Task>` ساخته میشه، صدا کردن `wake()` باعث میشه یک کپی از `Arc` به کانال task ها فرستاده بشه. در نهایت اجارکننده ما باید task رو برداره و poll اش کنه. بیاید همینو پیاده سازی کنیم:

```rust,ignore
{{#include ../../examples/02_04_executor/src/lib.rs:executor_run}}
```

تبریک میگم! ما الان یک اجراکننده Future داریم که کار میکنه. حتی الا میتونیم با این اجارکننده عملیات `asyn/.await` و Future های شخصی سازی شده رو انجام بدیم. عملیاتی مثل `TimeFuture` که قبلا نوشتیمش:

```rust,edition2018,ignore
{{#include ../../examples/02_04_executor/src/lib.rs:main}}
```

[بیدار کردن یک عملیات async با waker]: ./03_wakeups.md
