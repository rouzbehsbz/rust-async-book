<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js rust">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>اجراکننده ها و IO سیستم - برنامه نویسی Async در زبان Rust</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/custom.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "rust";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../00_introduction/01_introduction.html"><strong aria-hidden="true">1.</strong> چند تا نکته</a></li><li class="chapter-item expanded "><a href="../01_getting_started/01_chapter.html"><strong aria-hidden="true">2.</strong> مقدمه و شروع کار</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../01_getting_started/02_why_async.html"><strong aria-hidden="true">2.1.</strong> چرا Async ؟</a></li><li class="chapter-item expanded "><a href="../01_getting_started/03_state_of_async_rust.html"><strong aria-hidden="true">2.2.</strong> وضعیت کنونی Rust در حالت Async</a></li><li class="chapter-item expanded "><a href="../01_getting_started/04_async_await_primer.html"><strong aria-hidden="true">2.3.</strong> کلیدواژه های async/await</a></li></ol></li><li class="chapter-item expanded "><a href="../02_execution/01_chapter.html"><strong aria-hidden="true">3.</strong> زیر و بم اجرای کد های Async با Future</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../02_execution/02_future.html"><strong aria-hidden="true">3.1.</strong> نگاه دقیق به Future Trait</a></li><li class="chapter-item expanded "><a href="../02_execution/03_wakeups.html"><strong aria-hidden="true">3.2.</strong> بیدار کردن یک عملیات Async با Waker</a></li><li class="chapter-item expanded "><a href="../02_execution/04_executor.html"><strong aria-hidden="true">3.3.</strong> پیاده سازی یک اجراکننده برای عملیات Async</a></li><li class="chapter-item expanded "><a href="../02_execution/05_io.html" class="active"><strong aria-hidden="true">3.4.</strong> اجراکننده ها و IO سیستم</a></li></ol></li><li class="chapter-item expanded "><a href="../03_async_await/01_chapter.html"><strong aria-hidden="true">4.</strong> async/await</a></li><li class="chapter-item expanded "><a href="../04_pinning/01_chapter.html"><strong aria-hidden="true">5.</strong> Pin کردن</a></li><li class="chapter-item expanded "><a href="../05_streams/01_chapter.html"><strong aria-hidden="true">6.</strong> Stream ها</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../05_streams/02_iteration_and_concurrency.html"><strong aria-hidden="true">6.1.</strong> پیمایش و همزمانی ها در کد</a></li></ol></li><li class="chapter-item expanded "><a href="../06_multiple_futures/01_chapter.html"><strong aria-hidden="true">7.</strong> اجرا کردن چندین Future به طور همزمان</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../06_multiple_futures/02_join.html"><strong aria-hidden="true">7.1.</strong> ماکرو !join</a></li><li class="chapter-item expanded "><a href="../06_multiple_futures/03_select.html"><strong aria-hidden="true">7.2.</strong> ماکرو !select</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.3.</strong> تکمیل نشده: Spawn کردن</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.4.</strong> تکمیل نشده: متوقف کردن و Timeout ها</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.5.</strong> تکمیل نشده: Future های بدون ترتیب</div></li></ol></li><li class="chapter-item expanded "><a href="../07_workarounds/01_chapter.html"><strong aria-hidden="true">8.</strong> راه حل هایی که باید بدونیم و دوستشون داشته باشیم</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../07_workarounds/02_err_in_async_blocks.html"><strong aria-hidden="true">8.1.</strong> علامت ؟ در بلوک های کد Async</a></li><li class="chapter-item expanded "><a href="../07_workarounds/03_send_approximation.html"><strong aria-hidden="true">8.2.</strong> Send و همزمانی ترد ها</a></li><li class="chapter-item expanded "><a href="../07_workarounds/04_recursion.html"><strong aria-hidden="true">8.3.</strong> بازگشتی ها</a></li><li class="chapter-item expanded "><a href="../07_workarounds/05_async_in_traits.html"><strong aria-hidden="true">8.4.</strong> Async در Trait ها</a></li></ol></li><li class="chapter-item expanded "><a href="../08_ecosystem/00_chapter.html"><strong aria-hidden="true">9.</strong> اکوسیستم کد Async</a></li><li class="chapter-item expanded "><a href="../09_example/00_intro.html"><strong aria-hidden="true">10.</strong> پروژه نهایی: سرور HTTP</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../09_example/01_running_async_code.html"><strong aria-hidden="true">10.1.</strong> اجرا کردن کد Async</a></li><li class="chapter-item expanded "><a href="../09_example/02_handling_connections_concurrently.html"><strong aria-hidden="true">10.2.</strong> پردازش کانکشن ها به صورت همزمان</a></li><li class="chapter-item expanded "><a href="../09_example/03_tests.html"><strong aria-hidden="true">10.3.</strong> تست کردن سرور</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.</strong> تکمیل نشده: I/O</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">11.1.</strong> تکمیل نشده: AsyncRead و AsyncWrite</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.</strong> تکمیل نشده: الگو های طراحی در برنامه نویسی Async: راه حل ها و پیشنهاد ها</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">12.1.</strong> تکمیل نشده: مدل سازی سرور ها و الگوی طراحی سیستم های Request/Response</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.2.</strong> تکمیل نشده: مدیریت State های اشتراکی و Share شده</div></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">برنامه نویسی Async در زبان Rust</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rouzbehsbz/rust-async-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="اجراکننده-ها-و-io-سیستم"><a class="header" href="#اجراکننده-ها-و-io-سیستم">اجراکننده ها و IO سیستم</a></h1>
<p>توی قسمت قبلی در بخش <a href="./02_future.html">نگاه دقیق به Future Trait</a> راجب این مثال از خوندن socket به صورت async که یک Future بود بحث کردیم:</p>
<pre><code class="language-rust ignore">pub struct SocketRead&lt;'a&gt; {
    socket: &amp;'a Socket,
}

impl SimpleFuture for SocketRead&lt;'_&gt; {
    type Output = Vec&lt;u8&gt;;

    fn poll(&amp;mut self, wake: fn()) -&gt; Poll&lt;Self::Output&gt; {
        if self.socket.has_data_to_read() {
            // سوکت دیتا رو آماده داره -- بخونش داخل یه بافر و برگردونش
            Poll::Ready(self.socket.read_buf())
        } else {
            // سوکت هنوز دیتایی نداره
            //
            // تابع &quot;بیدار شدن&quot; رو زمانی که دیتا آماده بود صدا بزن.
            // وقتی دیتا آماده باشه تابع &quot;بیدار شدن&quot; صدا زده میشه و در نتیجه
            // اون &quot;فیوچر&quot; میدونه که الان باید &quot;پول&quot; رو صدا بزنه دوباره و دیتا رو بگیره
            self.socket.set_readable_callback(wake);
            Poll::Pending
        }
    }
}
</code></pre>
<p>این Future دیتای موجود socket رو میخونه، و اگر دیتای برای خوندن موجود نباشه، به اجراکننده میگه، و ازش میخواد که task هاش صدا زده بشن یا دوباره بیدار بشن در زمانی که دیتایی برای خوندن موجود باشه. با این حال، توی این مثال واضح نیست که تایپ <code>Socket</code> چجوری
پیاده سازی شده یا به صورت دقیق تر، مشخص نیست که تابع <code>set_readable_callback</code> چجوری کار میکنه.
چجوری میتونیم <code>wake()</code> رو فراخونی کنیم زمانی که socket چیزی برای خوندن داشته باشه ؟ یه راه حل اینه که یک thread به صورت مداوم چک کنه که آیا <code>socket</code> دیتایی برای خوندن داره یا نه و در زمان مناسب <code>wake()</code> رو فراخونی کنه. البته این روش اصلا بهینه نیست، چون داریم برای هر IO ای که مسدود کننده (blocking) هست یک thread باز میکنیم. این روش باعث میشه کارآمدی کد async ما خیلی پایین باشه.</p>
<p>در واقعیت، این مشکل با یک سری کتابخونه هایی که به اصطلاح آگاه به IO مسدود کننده سیستم هستن حل شده، مثل <code>epoll</code> روی لینوکس، <code>kqueue</code> روی FreeBSD و MacOS، IOCP روی ویندوز و <code>port</code> رو Fuchsia همه ی اینا داخل Rust از طریق crate ای به نام <a href="https://github.com/tokio-rs/mio"><code>mio</code></a> که به صورت cross platform دسترسی به این کتابخونه های سیستمی رو فراهم میکنه به صورت آماده وجود داره. این کتابخونه ها این امکان رو فراهم میکنن که یک thread رو چندین عملیات IO async مسدود بشه و زمانی نتیجش برگرده که یکی از اون event ها انجام شده و نتیجش حاضره. تو عمل استفاده از API این کتابخونه ها یه چیزی شبیه مثال زیره:</p>
<pre><code class="language-rust ignore">
struct IoBlocker {
    /* ... */
}

struct Event {
    // یک آی دی یکتا که مشخص کننده رویداد هست و با این آی دی لیست شده
    id: usize,

    // یک سری سیگنال که برای جوابشون صبر میکنه
    signals: Signals,
}

impl IoBlocker {
    /// ساخت یک کالکشن از عملیات ناهمزمان برای رویداد های &quot;آی او&quot; که برای گرفتن جوابشون ترد بلاک یا مسدود میشه
    fn new() -&gt; Self { /* ... */ }

    /// تعریف یک رویداد خاص برای بررسی در آینده
    fn add_io_event_interest(
        &amp;self,

        /// آبجکتی که رویداد توی اون اتفاق میفته
        io_object: &amp;IoObject,

        /// یک سری از سینگنال هایی که درون آبجکت بالا پدید میان
        /// که در نتیجه اون رویدادی باید اتفاق بیفته که اون رویداد با یک آی دی یکتا مشخص شده
        event: Event,
    ) { /* ... */ }

    /// بلاک شدن و مسدود شدن تا زمانی که یکی از رویداد ها اتفاق بیفته
    fn block(&amp;self) -&gt; Event { /* ... */ }
}

let mut io_blocker = IoBlocker::new();
io_blocker.add_io_event_interest(
    &amp;socket_1,
    Event { id: 1, signals: READABLE },
);
io_blocker.add_io_event_interest(
    &amp;socket_2,
    Event { id: 2, signals: READABLE | WRITABLE },
);
let event = io_blocker.block();

// اگر سوکت 1 زمانی قبال خوندن بشه برای مثال چاپ میشه: سوکت 1 آماده خوندن هست
println!(&quot;Socket {:?} is now {:?}&quot;, event.id, event.signals);
</code></pre>
<p>اجراکننده های Future میتونن از این کتابخونه های سیستمی استفاده کنن تا امکان اجرا شدن callback این Object های IO async مثل socket ها موقعی که event مربوطه اتفاق میفته فراهم بشه.
توی مثال مربوط به <code>SocketRead</code> در بالا، تابع <code>Socket::set_readable_callback</code> یه چیزی شبیه کد پایینه:</p>
<pre><code class="language-rust ignore">impl Socket {
    fn set_readable_callback(&amp;self, waker: Waker) {
        // یک رفرنس از اجراکننده ای که قرار اجرا کنه
        // که البته خیلیا این رو به صورت کلی داخل اون تردی که قراره اجرا بشه میارن
        // اما اینجا یک رفرنس از اون پاس داده شده تا از این رفرنس استفاده بشه
        let local_executor = self.local_executor;

        // یک ای دی یکتا برای این آبجکت آی او
        let id = self.id;

        // تابع بیدارکننده رو توی مپ اجراککنده ذخیره میکنیم تا بعدا وقت رویداد های آی او
        // اتفاق افتادن بتونه صداشون بزنه
        local_executor.event_map.insert(id, waker);
        local_executor.add_io_event_interest(
            &amp;self.socket_file_descriptor,
            Event { id, signals: READABLE },
        );
    }
}
</code></pre>
<p>حالا ما میتونیم فقط یک اجراکننده روی thread داشته باشیم تا رویداد ها و event های IO رو بگیره و <code>Waker</code> متناسب با اون رو فعال کنه، که باعث میشه task مربوطه انجام بشه. همین مساله باعث میشه که اجراکننده فرصت داشته باشه تا task های بیشتری رو اجرا کنه قبل از اینکه دوباره بره و چک کنه event جدید IO ای برای اجرا کردن داره یا نه (و این چرخه همینجور ادامه داره ...).</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../02_execution/04_executor.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../03_async_await/01_chapter.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../02_execution/04_executor.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../03_async_await/01_chapter.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
