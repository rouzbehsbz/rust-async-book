<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js rust">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>بیدار کردن یک عملیات Async با Waker - برنامه نویسی Async در زبان Rust</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/custom.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "rust";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../00_introduction/01_introduction.html"><strong aria-hidden="true">1.</strong> چند تا نکته</a></li><li class="chapter-item expanded "><a href="../01_getting_started/01_chapter.html"><strong aria-hidden="true">2.</strong> مقدمه و شروع کار</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../01_getting_started/02_why_async.html"><strong aria-hidden="true">2.1.</strong> چرا Async ؟</a></li><li class="chapter-item expanded "><a href="../01_getting_started/03_state_of_async_rust.html"><strong aria-hidden="true">2.2.</strong> وضعیت کنونی Rust در حالت Async</a></li><li class="chapter-item expanded "><a href="../01_getting_started/04_async_await_primer.html"><strong aria-hidden="true">2.3.</strong> کلیدواژه های async/await</a></li></ol></li><li class="chapter-item expanded "><a href="../02_execution/01_chapter.html"><strong aria-hidden="true">3.</strong> زیر و بم اجرای کد های Async با Future</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../02_execution/02_future.html"><strong aria-hidden="true">3.1.</strong> نگاه دقیق به Future Trait</a></li><li class="chapter-item expanded "><a href="../02_execution/03_wakeups.html" class="active"><strong aria-hidden="true">3.2.</strong> بیدار کردن یک عملیات Async با Waker</a></li><li class="chapter-item expanded "><a href="../02_execution/04_executor.html"><strong aria-hidden="true">3.3.</strong> پیاده سازی یک اجراکننده برای عملیات Async</a></li><li class="chapter-item expanded "><a href="../02_execution/05_io.html"><strong aria-hidden="true">3.4.</strong> اجراکننده ها و IO سیستم</a></li></ol></li><li class="chapter-item expanded "><a href="../03_async_await/01_chapter.html"><strong aria-hidden="true">4.</strong> async/await</a></li><li class="chapter-item expanded "><a href="../04_pinning/01_chapter.html"><strong aria-hidden="true">5.</strong> Pin کردن</a></li><li class="chapter-item expanded "><a href="../05_streams/01_chapter.html"><strong aria-hidden="true">6.</strong> Stream ها</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../05_streams/02_iteration_and_concurrency.html"><strong aria-hidden="true">6.1.</strong> پیمایش و همزمانی ها در کد</a></li></ol></li><li class="chapter-item expanded "><a href="../06_multiple_futures/01_chapter.html"><strong aria-hidden="true">7.</strong> اجرا کردن چندین Future به طور همزمان</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../06_multiple_futures/02_join.html"><strong aria-hidden="true">7.1.</strong> ماکرو !join</a></li><li class="chapter-item expanded "><a href="../06_multiple_futures/03_select.html"><strong aria-hidden="true">7.2.</strong> ماکرو !select</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.3.</strong> تکمیل نشده: Spawn کردن</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.4.</strong> تکمیل نشده: متوقف کردن و Timeout ها</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.5.</strong> تکمیل نشده: Future های بدون ترتیب</div></li></ol></li><li class="chapter-item expanded "><a href="../07_workarounds/01_chapter.html"><strong aria-hidden="true">8.</strong> راه حل هایی که باید بدونیم و دوستشون داشته باشیم</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../07_workarounds/02_err_in_async_blocks.html"><strong aria-hidden="true">8.1.</strong> علامت ؟ در بلوک های کد Async</a></li><li class="chapter-item expanded "><a href="../07_workarounds/03_send_approximation.html"><strong aria-hidden="true">8.2.</strong> Send و همزمانی ترد ها</a></li><li class="chapter-item expanded "><a href="../07_workarounds/04_recursion.html"><strong aria-hidden="true">8.3.</strong> بازگشتی ها</a></li><li class="chapter-item expanded "><a href="../07_workarounds/05_async_in_traits.html"><strong aria-hidden="true">8.4.</strong> Async در Trait ها</a></li></ol></li><li class="chapter-item expanded "><a href="../08_ecosystem/00_chapter.html"><strong aria-hidden="true">9.</strong> اکوسیستم کد Async</a></li><li class="chapter-item expanded "><a href="../09_example/00_intro.html"><strong aria-hidden="true">10.</strong> پروژه نهایی: سرور HTTP</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../09_example/01_running_async_code.html"><strong aria-hidden="true">10.1.</strong> اجرا کردن کد Async</a></li><li class="chapter-item expanded "><a href="../09_example/02_handling_connections_concurrently.html"><strong aria-hidden="true">10.2.</strong> پردازش کانکشن ها به صورت همزمان</a></li><li class="chapter-item expanded "><a href="../09_example/03_tests.html"><strong aria-hidden="true">10.3.</strong> تست کردن سرور</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.</strong> تکمیل نشده: I/O</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">11.1.</strong> تکمیل نشده: AsyncRead و AsyncWrite</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.</strong> تکمیل نشده: الگو های طراحی در برنامه نویسی Async: راه حل ها و پیشنهاد ها</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">12.1.</strong> تکمیل نشده: مدل سازی سرور ها و الگوی طراحی سیستم های Request/Response</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.2.</strong> تکمیل نشده: مدیریت State های اشتراکی و Share شده</div></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">برنامه نویسی Async در زبان Rust</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rouzbehsbz/rust-async-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="بیدار-کردن-یک-عملیات-async-با-waker"><a class="header" href="#بیدار-کردن-یک-عملیات-async-با-waker">بیدار کردن یک عملیات Async با Waker</a></h1>
<p>این خیلی عادیه که Future ها همون بار اولی که poll میشن قادر به اتمام کارشون نباشن.
تو این موقعیت، Future باید اطمیانان حاصل کنه که در آینده دوباره poll میشه وقتی آمادس تا پردازش بیشتری رو جلو ببره.
این کار با استفاده از تایپ <code>Waker</code> انجام میشه.</p>
<p>هر زمانی که یه Future poll میشه، به عنوان قسمتی از یک کارواحد یا &quot;task&quot; poll میشه. task ها همون Future های سطح بالایی هستن که به یک اجراکننده داده شدن تا اجرا بشن.</p>
<p><code>Waker</code> یه متد <code>wake()</code> داره که کارش اینه که به اجرا کننده بگهئ task ای که بهش وصل شده رو صدا بزنه یا به اصطلاح بیدارش کنه. وقتی <code>wake()</code> وقتی <code>wake()</code> صدا زده میشه اجراکننده میدونه task ای که به <code>Waker</code> متصل شده آمادس تا پردازش بیشتری رو انجام بده و Future اون باید دوباره poll بشه.</p>
<p><code>Waker</code> متد <code>clone()</code> هم پیاده سازی کرده که میتونه تو جاهای مختلف کپی و ذخیره بشه.</p>
<p>خب حالا بیاید سعی کنیم یه تایمر ساده Future با استفاده از <code>Waker</code> بسازیم:</p>
<h2 id="مثال-عملی-یک-تایمر-بسازید"><a class="header" href="#مثال-عملی-یک-تایمر-بسازید">مثال عملی: یک تایمر بسازید</a></h2>
<p>برای درک بهتر این مثال، وقتی تایمر درست شد ما میایم یک thread جدید ایجاد میکنیم و برای مدتی که اون تایمر ست شده thread رو تو حالت sleep میبریم و بعد از اون یه signal به تایمر Future میدیم که متوجه بشه تایم به اتمام رسیده.</p>
<p>اول، یه پروژه جدید با دستور <code>cargo new --lib time_future</code> ایجاد کنید و چیزایی که لازم داریم رو به <code>src/lib.rs</code> اضافه کنید:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::{
    future::Future,
    pin::Pin,
    sync::{Arc, Mutex},
    task::{Context, Poll, Waker},
    thread,
    time::Duration,
};
<span class="boring">}
</span></code></pre></pre>
<p>بیاین اول از تعریف کردن خود تایپ Future شروع کنیم. Future ما نیاز به یک راهی داره تا بتونه با thread ارتباط برقرار کنه و متوجه تموم شدن تایم در اون thread بشه و در نهایت Future کارش با موفقت به اتمام برسه. برای این کار از <code>Arc&lt;Mutex&lt;..&gt;&gt;</code> برا ذخیره مقادیرمون استفاده میکنیم تا بتونیم از طریق اون بین Future و thread مون ارتباط برقرار کنیم.</p>
<pre><code class="language-rust ignore">pub struct TimerFuture {
    shared_state: Arc&lt;Mutex&lt;SharedState&gt;&gt;,
}

/// وضعیت اشتراکی بین &quot;فیوچر&quot; و &quot;ترد&quot; ی که منتظر وایساده
struct SharedState {
    /// این مقدار نشون میده که تایمر کارش تموم شده یا نه
    completed: bool,

    /// تابع &quot;بیدار شونده&quot; برای این تایمر. که وقتی تایمر کارش تموم شد
    /// این تابع صدا زده بشه و ادامه عملیات انجام بشه
    waker: Option&lt;Waker&gt;,
}
</code></pre>
<p>حالا بیاین واقغا خود <code>Future</code> رو پیاده سازی کنیم!</p>
<pre><code class="language-rust ignore">impl Future for TimerFuture {
    type Output = ();
    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt; {
        // بررسی کن میکنه ببینه تایمر کارش تموم شده یا نه
        let mut shared_state = self.shared_state.lock().unwrap();
        if shared_state.completed {
            Poll::Ready(())
        } else {
            // تابع &quot;بیدار شونده&quot; رو ست میکنیم تا ترد بتونه
            // در زمانی که تایمر کارش تموم میشه اون صدا بزنه
            //
            // اینجا فقط یک بار عملیات کپی کردن از تابع &quot;بیدار شونده&quot; انجام میشه به جای
            // اینکه هر سری بیاد و کپی کنه
            //
            // البته میشه از تابع زیر هم برای بررسی اینکه آیا اون &quot;فیوچر&quot; بیدار میشه یا نه
            // هم استفاده کرد ولی برای اینکه مثال رو ساده نگه داریم اینجوری استفاده کردیم
            // `Waker::will_wake`
            shared_state.waker = Some(cx.waker().clone());
            Poll::Pending
        }
    }
}
</code></pre>
<p>خیلی راحت بود مگه نه ؟ اگه thread مقدار <code>shared_state.completed = true</code> رو ست کنه ما کارمون تمومه! در غیر این صورت میایم <code>Waker</code> رو clone برای task فعلی clone میکنیم به منتقلش میکنیم به <code>shared_state.waker</code>. به این ترتیب thread میتونه task رو دوباره بیدار کنه.</p>
<p>این خیلی مهمه که هر موقع که Future دوباره poll میشه ما <code>Waker</code> رو آپدیت کنیم، چون ممکنه Future یه task دیگه رو با یک <code>Waker</code> دیگه رو منتقل کرده باشه. این داستان زمانی اتفاق میفته که Future ها بین task های مختلف وقتی poll میشن جا به جا بشن.</p>
<p>در نهایت ما به یه API نیاز داریم تا واقعا تایمر رو بسازیم و thread رو شروع کنیم:</p>
<pre><code class="language-rust ignore">impl TimerFuture {
    /// یک &quot;فیوچر&quot; جدید درست میکنه زمانی که تایمر کارش انجام میشه
    pub fn new(duration: Duration) -&gt; Self {
        let shared_state = Arc::new(Mutex::new(SharedState {
            completed: false,
            waker: None,
        }));

        // یک ترد جدید میسازه
        let thread_shared_state = shared_state.clone();
        thread::spawn(move || {
            thread::sleep(duration);
            let mut shared_state = thread_shared_state.lock().unwrap();
            // زمانی که تایمر تموم شد یک سیگنال میفرسته و آخرین تسکی که &quot;پول&quot; شده رو بیدار میکنه
            // البته اگه تسکی موجود باشه
            shared_state.completed = true;
            if let Some(waker) = shared_state.waker.take() {
                waker.wake()
            }
        });

        TimerFuture { shared_state }
    }
}
</code></pre>
<p>این تمام چیزی بود که نیاز داشتیم تا یک تایمر Future ساده بسازیم. فقط کاش یه اجراکننده داشتیم که میتونستیم Future رو روی اون اجرا کنیم ...</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../02_execution/02_future.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../02_execution/04_executor.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../02_execution/02_future.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../02_execution/04_executor.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
